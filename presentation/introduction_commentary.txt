Welcome to the introductory presentation about extensible binary universal protocol.

This presentation covers concepts and technical aspects of the project and ends with short demo of the editor tool included in the current prototype implementation.

-- What it is
XBUP is concept of a binary data protocol which has strong focus on abstraction as the primary concept across multiple levels. While on the lowest level data are basically represented as tree of binary blobs, protocol defines mechanisms to build complex data types on higher levels and also includes transformation layer for automatic or manual data conversions and compatibility handling.

-- Goals
Goals for the protocol are:
universal - to support as wide types of data as possible, delivery methods like storage, streaming, parallel processing
independent - this means no dependency on specific platform, architecture or programming language as well as depency on some product, company, country or even spoken language
 declarative - protocol should be self sufficient for data type definition and with the ability to build data types by combining existing ones
normative - there should be an option to provide reference form for the data representation
flexible - compatibility and extensibility should be included and it should be possible to use part of the protocol for specific needs
efficient - there should be ability to compact and compress data to various degree and support data indexing and caching

-- Motivation
As to what the motivation is behind this project, it would be great to have structured binary data with well defined meaning which could be easily viewed and edited and manipulated with including both graphical and textual tools with support for multiple languages and syntaxes.
Another use for this protocol could be to provide both independent API and data interchange format and with automatic transformation between both of them, and it should be possible to utilize the protocol to enhance approach for modular applications design.
With the multiple levels of expresiveness and capability to define unlimited number of additional properties, it should be also possible to utilize the protocol for definition and storage of specialized scientific data
and as the protocol should support both external or integrated specification, it might be possible to use it for long storage with.

-- Usable for
With this capabilities, it should be possible to use the format for example for multimedia files, like audio, video, animations or 3D data. It might be also possible to use format for serialization of non-structured data as well as remote or local method execution calls. It should be also possible to use format to store data and metadata for filesystem or compressed archive and dynamic numeric values should allow to support data in basically unlimited sized. Transformation layer should allow to also handle segmented, paged or fragmented data as well as operation atomicity for parallel access for structural data or even database use. 

-- Example: Bitmap Picture
As an example, lets consider image format. While bitmap image might seem to be simple, there is still factors like color model, palette and compression to consider. But much more complexity to image format could be introduced with metadata related to image creation, especially with modern smartphones which boost wide variety of sensors. If unified method for storage would be available, same metadata format could be used for different formats as well, for example for audio or video recordings and so on.

-- Universal Data Representation
Next slides attempts to explain more technical details starting with the basic goal to build universal protocol. Basic premise is that it should be possible to include any resonable binary data, but still attempt to adhere to the structure of the data when possible. Primary point of view for abstraction should be ordered set and sequence as defined in set theory.

-- UB Encoding
Data in protocol are organized as a sequence of octets - also called bytes. To represent single value from countable set, following varying length encoding is used. It combines unary encoding to encode length and binary encoding to represent value. On current slide, there is list of binary codes on the left side representing specific non-negative integer values on the right side. Values are shifted so that there is only single code for each value.

-- Block Tree Structure
Tree structure built using blocks is used which should be good enough for normal cases. Goal here is to use as simple approach as possible while still providing sufficient capability to represent many different structures of data, which should be mapped to tree using pointers. As the data stream can also carry infinite stream of data, support for sequences with length not known in advance or infinite should be included.

-- File Structure
Single document is typically represented as a single block, but there can be additional optional tail data present. There is also option for file header which contains information about protocol version and contains padding data to avoid issues in systems which uses file type detection by beginning of the file. File header is not necessary when protocol version is known already, for example in multiple data streams connecting to single service.

-- Data Block
Block consists of two parts: sequence of values encoded using unary-binary encoding and sequence of child blocks or single data blob of general data.

-- Data Block Detail
There are actually two values at the beginning of the block which are used to specify size of space available. If there are no additional values second part is considered as general data blob instead of a list of child nodes. There is also support for blocks with infinite or dynamic size which have to be terminated with zero mark.

-- Examples of Blocks
Here you can see few very crude examples of blocks as hexadecimal codes of the byte values. 

-- Examples of Blocks 2
Might be slightly easier to understand with highlighting size of first part red, size of second part blue and child blocks as yellow.

-- Examples of Blocks 3

-- Data Type Definition
As next step first two attribute values in the data blocks are used for point to a specific data type definition. Rest of the attribute values and child blocks then corresponds to the defined sequence of values of the type. Types can be organized into catalog of types and linked to document. Protocol itself defines one main catalog which contains set of basic block types which can be used both directly in documents or referred to build more complex types. Catalog can also contain functions or methods definition for various purposes like data transformations or remote calls.

-- Example of Block Type
Data types can create structure of dependecies and have additional properties which can allow additional methods for handling specified type. Type can for example specify not just that value is number, but also unit of measurement, which will prevent mixing different units and allow conversion, often automatically.

-- Data Transformations
As part of the protocol, there is also support for data transformations included. Transformations can be used for automatic conversion between different data types or versions and can be provided to applications as a background system service or separate library. This should allow to provide new functionality without necessity to get new version of the applications if desired and is for example used in multimedia frameworks for adding new codecs and container formats.

-- Example Use of Service
Example here shows simplified case for bitmap editor application which uses service to open files. This arrangement allows to add support for additional image file types with different compression without necessity to modify the application itself.

-- Execution Nodes
Transformation services can be also executed remotelly if desired and combined together as computation nodes to form some kind of data processing cluster. Execution nodes can also provide local copy of catalog of types for faster handling. On the other hand, remote nodes can be used for database or backup purposes.  

-- Editor
One of the basic tools is document editor. It should show document as a tree, text or as binary data and provide support for catalog. Editor can be extended with various visualization tools for for example viewing pictures, playing multimedia or editing specific structured data as well with custom syntaxes or manual and automatic transformations.

-- Demo
Prototype implementation is written in Java and editor tool has currently only limited functionality. For short demo basic tool contains few sample documents which can be used to test type handling. Data block can be viewed as properties list, type information, textual form or as binary data. When available for specific data type, custom viewer or row editor can be shown. Editor also contains browser for local catalog which is updated from central repository and can be browsed. Catalog can be currently edited for testing purposes. There is also some basic support for adding and editing blocks.

-- Next Steps
Project is still in early stage and lot of work need to be done. While libraries and support for catalog are partially covered in the prototype implemented, work on execution service barely started. Support for transformations and programming language are still just a concept as well as definition of wide range of types and data formats.

-- Questions
If you are interested about this project, you can visit project's website and browse documentation or try current prototype implementation. Project is open source using Apache license with codes available on GitHub. You can also discuss about project on Element chat or write an email.

-- End
That's all for now. Thanks for watching.
