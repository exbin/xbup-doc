.pl 10.0i
.po 0
.ll 7.2i
.lt 7.2i
.nr LL 7.2i
.nr LT 7.2i
.ds LF Miroslav Hajda 
.ds RF FORMFEED[Page %]
.ds LH Internet-Draft
.ds RH <Issue Date>
.ds CH XBUP
.ds CF Expires <Expiry Date>
.hy 0
.nh
.ad l
.in 0

.nf
.tl 'Internet-Draft'XBUP'Miroslav Hajda'
.tl 'Intended Status: Proposed Standard''(ExBin Project)'
.tl 'Expires: <Expiry Date>''<Issue Date>'
.fi

.\" Note. The ".tl" directive is used to generate the leading header 
.\" in Internet drafts. The information specified after ".tl" provides
.\" left, center and right components of a line separated by the ' character
.\" in the following manner:
.\" 
.\"  .tl '<left component>'<center component>'<right component>'
.\"
.\" Only the left and right components are used in Internet-draft headers
.\" This and other comments in this template can safely be deleted.

.ce 2
Extensible Binary Universal Protocol (XBUP)
draft-ietf-exbin-xbup-core-00
.fi
.in 3


.ti 0
Abstract

The Extensible Binary Universal Protocol (XBUP) is a general purpose binary data protocol and file format with primary focus on data abstraction and transformation.

This documentation describes specification of bottom levels of protocol and set of basic data types and recommended API.

.ti 0
Contributing

This document is being worked on by ExBin Project. Primary goal is to gather comments and raise interest in this project.

To participate on the development of this project, visit http://xbup.exbin.org/?development

.ti 0
Status of this Memo

This Internet-Draft is submitted to IETF in full conformance with the provisions of BCP\078 and BCP\079.

Internet-Drafts are working documents of the Internet Engineering Task Force (IETF), its areas, and its working groups.  Note that other groups may also distribute working documents as \%Internet-Drafts.

Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."

The list of current Internet-Drafts can be accessed at \%http://www.ietf.org/1id-abstracts.html

The list of Internet-Draft Shadow Directories can be accessed at http://www.ietf.org/shadow.html


.ti 0
Copyright and License Notice\" Boilerplate from December 2009

.\" NOTE: Insert current <year> in the following paragraph
Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.

This document is subject to BCP\078 and the IETF Trust's Legal Provisions Relating to IETF Documents \%(http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section\04.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.



.\" \# TD4  -- Set TOC depth by altering this value (TD5 = depth 5)
.\" \# TOC  -- Beginning of auto updated Table of Contents
.in 0
Table of Contents

.nf
   1  Introduction  . . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.1.  Objectives . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . .  4
   2.  XBUP Specification . . . . . . . . . . . . . . . . . . . . . .  4
     2.1. Level 0: Tree Structure . . . . . . . . . . . . . . . . . .  4
       2.1.1. UBNumber Encoding . . . . . . . . . . . . . . . . . . .  5
       2.1.2. Document  . . . . . . . . . . . . . . . . . . . . . . .  5
       2.1.3. Block . . . . . . . . . . . . . . . . . . . . . . . . .  6
       2.1.4. Validity  . . . . . . . . . . . . . . . . . . . . . . .  7
     2.2. Level 1: Block Types  . . . . . . . . . . . . . . . . . . .  8
       2.2.1. Block Type  . . . . . . . . . . . . . . . . . . . . . .  8
       2.2.2. Block Type Definition . . . . . . . . . . . . . . . . .  8
       2.2.3. Basic Blocks Definition . . . . . . . . . . . . . . . .  9
   3. Todo  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9
     3.1. Examples of Blocks  . . . . . . . . . . . . . . . . . . . . 10
     3.1. Appendix 1: Parsing . . . . . . . . . . . . . . . . . . . . 10
   4. Security Considerations . . . . . . . . . . . . . . . . . . . . 12
   5. IANA Considerations . . . . . . . . . . . . . . . . . . . . . . 12
   6. References  . . . . . . . . . . . . . . . . . . . . . . . . . . 12
     6.1.  Normative References . . . . . . . . . . . . . . . . . . . 12
     6.2.  Informative References . . . . . . . . . . . . . . . . . . 12
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 12
.fi
.in 3

.\" \# ETC -- End of auto updated Table of Contents

.bp
.ti 0
1  Introduction

The Extensible Binary Universal Protocol (XBUP) is a general purpose binary data protocol and file format with primary focus on abstraction and data transformation.

Key features:

 *  Unified block-tree structure - Minimalist tree structure based on integer and blob only

 *  Build-in and custom data types - Data type definitions and catalog of types

 *  Transformation framework - Automatic and manual data conversions and compatibility handling

Secondary goal is to include some advancements from markup languages like SGML/XML or data representation languages like YAML, JSON [RFC4627] or ASN.1.

This should cover capabilities like:

 *  Extensibility

 *  Unconstrained values

 *  Linking

 *  Namespaces

 *  Dynamic evolution

Primary focus on abstraction makes this protocol somewhat different compare to other similar binary formats which focus on efficiency, serialization or binary representation of mark-up language. Please see "Formats comparison" section for more.

.ti 0
1.1.  Objectives

The primary goal of this project is to create communication protocol/data format with the following characteristics, ordered by priority:

 *  Universal - Capable to represent any type of data, suitable for persistent and long-term storage and streaming

 *  Independent - Not tightly linked to particular spoken language, product, company, processing architecture or programming language

 *  Declarative - Self sufficient for data type definition and ability to build data types on top of each other and link them together

 *  Normative - Providing reference form for data representation

 *  Flexible - Support for data transformations, compatibility and extensibility

 *  Efficient - Effective data compacting / compression support for plain binary and structured data

.ti 0
1.2.  Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 [RFC2119].

This specification makes use of the following terminology:

Byte: Used in the sense of 8-bits binary data value as a synonym for "octet".

Parser: A software component that takes input data and builds a data structure

Decoder: A process that analyze input data stream to basic elements structure or sequence utilizing parser

Encoder: A process that constructs output data from elements structure or sequence - reverse method to decoder

Token: Atomic parse element

Stream: A sequence of data elements made available over time

.ti 0
2.  XBUP Specification

Specification of the protocol is split into separate levels. Each level builds on top of previous level adding new features and/or limitations.

Applications can also support particular level only including all lower levels when full support is not necessary.

.ti 0
2.1. Level 0: Tree Structure

Lowest protocol's level defines basic tree structure using two primitive types.

  * Attribute - Value encoded using UBNumber encoding

  * Blob - Sequence of bits (bytes) with unspecified length or length specified by some attribute

.ti 0
2.1.1. UBNumber Encoding

UBNumber is encoding which combines unary and binary encoding to represent values with dynamic length. It is typically representing natural non-negative integer number or value of any other type with mapping to countable set.

Encoding is similar to UTF-8, except that UBNumber is applied recursively when unary part reaches all bits of byte.

To decode value, non-zero bits are counted for length up to 8 bits and then rest of bits is used as value while value is also shifted so that there is only one code for each number.

Examples of the UBNatural - codes sequence of bits = value represented value in basic natural non-negative integer number:

.nf
  0 0000000                                         = 0
  0 0000001                                         = 1
  0 0000010                                         = 2
  0 0000011                                         = 3
\&  ...
  0 1111111                                         = 7Fh = 127
  10 000000 | 00000000                      = 80h = 128
  10 000000 | 00000001                      = 81h = 129
\&  ...
  10 111111 | 11111111                      = 407Fh = 16511
  110 00000 | 00000000 | 00000000   = 4080h = 16512
\&  ...
.fi

Various interpretations can be mapped on UBNumber encoding. For level 0 following two are used:

  * UBNatural encoding using directly value from UBNumber basic mapping

  * UBENatural where value 7Fh is reserved for infinity constant and higher values are shifted by one

.ti 0
2.1.2. Document

For version 0.2 of the document starts with fixed 6 bytes long blob called "Document Header" followed by a single block called "Root Block" and any data after root block are optional blob called "Tail Data".

Header for current version of protocol with hexadecimal codes. Explanation of the each value is non-conformant, primary use is padding to help systems which uses begining of file for identification of file type.

.nf
  +-------------------------------------------+
  | FE | Unary encoded size of cluster (byte) |
  | 00 | Reserved for future versions         |
  | 58 | Ascii constant 'X'                   |
  | 42 | Ascii constant 'B'                   |
  | 00 | UBNatural encoded major version      |
  | 02 | UBNatural encoded minor version      |
  +-------------------------------------------+
.fi

If it is known information, it is possible to omit header.

.ti 0
2.1.3. Block

There are 3 kinds of blocks: Node Block, Data Block and Terminator

Each block starts with single attribute:

  UBNatural attributePartSize

If attributePartSize equals 0 then this block is called "Terminator" and block ends.

Otherwise it is followed by blob of the length specified by attributePartSize in bytes. Data in attribute part are interpreted as a sequence of attributes encoded in UBNumber encoding.

First attribute in attribute part represents value:

  UBENatural dataPartSize

If dataPartSize value fills exactly whole attribute part then this block is called "Data Block".

Binary blob called data part follows after attribute part and has length in bytes specified by dataPartSize value or if dataPartSize equals infinity bytes in data part are processed and when byte with value zero is used as escape code and, following byte represents how many bytes of zero it represents or end of the data part if it equals zero as well.

If dataPartSize value fills only part of the attribute part then this block is called "Node Block".

Binary blob called data part follows after attribute part. Data in data part are interpreted as a sequence of (child) blocks.

Data part has length in bytes specified by dataPartSize value or if dataPartSize equals infinity, sequence of blocks must be terminated by terminator block.

After data part block ends.

.nf
  +---------------------------------------+
  | == First block's attribute ========== |
  |                                       |
  | UBNatural attributePartSize           |
  +---------------------------------------+
  | == Attribute part (optional) ======== |
  |                                       |
  | UBENatural dataPartSize               |
  | UBNumber attribute 1                  |
  | ...                                   |
  | UBNumber attribute n                  |
  +---------------------------------------+
  | == Data part (optional) ============= |
  |                                       |
  | Binary data or child blocks           |
  +---------------------------------------+
.fi

See block examples for better understanding.

.ti 0
2.1.4. Validity

Binary stream is structured correctly as XBUP document (well-formed) if the following conditions are met. Description of invalid state is also included for each condition.

  * Optional: Stream header must be present (Corrupted or missing header)

  * Optional: Header version must be in supported range (Unsupported header)

  * In each block the end of last attribute corresponds to the end of the attribute part (Attribute Overflow)

  * In each block the end of last subblock corresponds to the end of the data block part (Block Overflow)

  * The terminal block is present only in blocks where it belongs to (Unexpected Terminator)

  * End of file is after the end of the root block (Unexpected End)

.ti 0
2.2. Level 1: Block Types

Level 1 introduces block types and catalog of types. Since this level, if attribute is defined, but not present, it's value is considered as zero as in the form of UBNumber encoding.

.ti 0
2.2.1. Block Type

First two attributes in node block are interpreted as follows (somewhat similar to XML Namespaces):

  UBNatural - TypeGroup
.br
  UBNatural - BlockType

These two values determines blocks type.

Block types are organized into groups where TypeGroup value specifies to which group block type belongs and BlockType value specifies particular block type in the corresponding group.

TypeGroup with value 0 is basic build-in group and cannot be overridden. Basic blocks provides ability to specify meaning of other groups via block type declarations, definitions or links to catalog or external source.

.ti 0
2.2.2. Block Type Definition

Block type is defined as a sequence of operations over build-in or defined types. There are singular and list variants of 4 operations.

Each block type can be represented with one of eight of the following operations:

  * Single block - Appends single child block of any type.

  * Single attribute - Appends single attribute of any type.

  * Consist of definition - Appends single child block of defined type (as a component/element).

  * Append definition - Appends all attributes and all child blocks of defined type.

  * List of any blocks - Appends single attribute of type UBENatural to define count of blocks of any type and child blocks of that count. When count equals infinity, list of blocks ends with empty block.

  * List of attributes - Appends single attribute of type UBNatural to define count of attributes of any type and attributes of that count.

  * List of consist of definitions - Appends single attribute of type UBENatural to define count of blocks of defined type and child blocks of that count. When count equals infinity, list of blocks ends with empty block.

  * List of appended definitions - Appends single attribute of type UBNatural to define count of blocks of defined type and appends all attributes and all child blocks of defined type of that count.

To simplify syntax, currently following shortcuts are used:

any - Single block
.br
attribute - Single attribute
.br
block_type_name - Consist of definition
.br
+block_type_name - Append definition

List variants of the operations ends with brackets "[]".

.ti 0
2.2.3. Basic Blocks Definition

  * Undefined (0)

This block is used for undefined block types or data padding.

  * Document Declaration (1)


.ti 0
3. Todo

.\" Comment line providing info for the Authors or the RFC Editor
<Document text>

.in 6
.nf
Definitions and code {
  line 1
  line 2
}
.fi
.in 3

.\" Directives (e.g .ti and .in) and escape sequences (\, \&, \%, \" and \0) are used to control
.\" Formatting and are not displayed in the text document.

Special characters examples:
 
The characters \0, \&, \%, \" are not shown in text.
.\"
.\" You can display these character sequences in the text document by
.\" inserting the escape character '\'.
However, the characters \\0, \\&, \\%, \\" are displayed.

\&.ti 0  is displayed in text instead of used as a directive. 
.br
\&.\\"  is displayed in document instead of being treated as a comment

C:\\dir\\subdir\\file.ext  Shows inclusion of backslash "\\".

.ti 0
3.1. Examples of Blocks

  * Fixed size Node block with one attribute

.nf
+------------------------+
| 02 | AttributePartSize |
| 00 | DataPartSize      |
| 00 | Attribute 1       |
+------------------------+
.fi

  * Terminated node block with one attribute

.nf
+------------------------+
| 02 | AttributePartSize |
| 7F | DataPartSize      |
| 05 | Attribute 1       |
| 00 | Terminator
+------------------------+
.fi

  * Fixed size empty data block

.nf
+------------------------+
| 01 | AttributePartSize |
| 00 | DataPartSize      |
+------------------------+
.fi

  * Terminated empty data block

.nf
+---------------------------+
| 01 | AttributePartSize    |
| 7F | DataPartSize         |
| 00 | Data block escape    |
| 00 | Termination value    |
+---------------------------+
.fi

.ti 0
3.1. Appendix 1: Parsing

To process level 0 protocol following 4 types of tokens are used:

  * begin (terminationMode flag)

  * attribute (UBNumber value)

  * data (Binary data)

  * end

Following simplified grammar can be used for token processing.

.nf
Document ::= header + Block + data
Block ::= begin + Attributes + Blocks + end | begin + data + end
Blocks ::= Block + Blocks | epsilon
Attributes ::= attribute + Attributes | epsilon
.fi

.bp
.ti 0
4. Security Considerations

<Security considerations text>


.ti 0
5. IANA Considerations


<IANA considerations text>


.ti 0
6. References

.ti 0 
6.1.  Normative References

.in 14
.\" \# REF  -- Managed reference list. Syntax: [RFC]nnnn[;Label], ... ,[RFC]nnnn[;Label]
.\" \# 2119;KEYWORDS, 1776, RFC1925;TRUTHS
.\" \# ERF -- End of managed reference list
.\" ----------------------------------------
.\" The reference list can be changed at any time by altering the RFC list in the line below the .\" \# REF directive
.\" In order to execute any change, click on the 'Update All' button or select "Update 'Table of Contents' and References"
.\" from the "Edit" menu or press <F3>.
.\" NOTE: Managed reference list requires NroffEdit version 1.40 or later.

.ti 0
6.2.  Informative References

.in 14
.\" \# REF  -- Managed reference list. Syntax: [RFC]nnnn[;Label], ... ,[RFC]nnnn[;Label]
.\" \# 3514;EVILBIT, 5513, 5514
.\" \# ERF -- End of managed reference list
.in 3


.ti 0
Authors' Addresses

.sp
.nf
Miroslav Hajda
and
Zdechov, Czech Repubic

EMail: name@example.com
.sp
.fi

