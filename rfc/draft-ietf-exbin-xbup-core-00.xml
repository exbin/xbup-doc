<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM
  "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc strict="yes" ?>

<rfc
  category="std"
  docName="draft-ietf-exbin-xbup-core-00"
  ipr="trust200902"
  consensus="no"
  submissionType="IETF"
  xml:lang="en"
>

<front>
<title abbrev="XBUP">
Extensible Binary Universal Protocol (XBUP)
</title>

<author fullname="Miroslav Hajda" surname="Hajda" initials="M.">
<organization>ExBin Project</organization>
<address>
<email>exbinproject@gmail.com</email>
<uri>https://exbin.org/</uri>
</address>
</author>

<date year="2020" month="March"/>

<area>General</area>
<workgroup>(TBD)</workgroup>
<keyword>Binary</keyword>
<keyword>Protocol</keyword>

<abstract>
<t>The Extensible Binary Universal Protocol (XBUP) is a prototype of general purpose binary data protocol and file format with primary focus on data abstraction and transformation.</t>
<t>This proposal describes specification of bottom levels of protocol and set of basic data types and recommended API.</t>
</abstract>

<note title="Contributing">
<t>This document is being worked on by ExBin Project. Primary goal is to gather comments and raise interest in this project.</t>
<t>To participate on the development of this project, visit <eref target="https://xbup.exbin.org/?participate">https://xbup.exbin.org/?participate</eref>.</t>
</note>

</front>

<middle>

<section anchor="intro" title="Introduction">

<t>The Extensible Binary Universal Protocol (XBUP) is a prototype of general purpose multi-layer binary data protocol and file format with primary focus on abstraction and data transformation.</t>

<t>Key features:
<list style="symbols">
 <t>Unified block-tree structure - Minimalist tree structure based on integer and binary blob only</t>
 <t>Build-in and custom data types - Support for data type definitions and catalog of types</t>
 <t>Transformation framework - Automatic and manual data conversions and compatibility handling</t>
</list>
</t>

<t>Secondary features includes some capabilities inspired by markup languages like SGML/XML and data representation languages like YAML, JSON [RFC4627] and similar binary formats like ASN.1, HDF5 and efficient XML.
<list style="symbols">
 <t>Extensibility</t>
 <t>Unconstrained values</t>
 <t>Internal and external referencing</t>
 <t>Data life-cycle / definition evolution</t>
</list>
</t>

<t>Primary focus on abstraction makes this protocol somewhat different compare to other similar binary formats which focus on efficiency, serialization or binary representation of specific mark-up language. Please see "Formats comparison" section for more.</t>

<section anchor="objectives" title="Objectives">

<t>The primary goal of this project is to create a communication protocol / data format with the following characteristics, ordered by priority:

<list style="symbols">
 <t>Universal - Capable to represent any type of data, suitable for wide use including streaming, long-term storage and parallel access</t>
 <t>Independent - Not tightly linked to particular spoken language, product, company, processing architecture or programming language</t>
 <t>Declarative - Self sufficient for data type definition and ability to build data types on top of each other and combine them together</t>
 <t>Normative - Providing reference form for data representation</t>
 <t>Flexible - Support for data transformations, compatibility and extensibility</t>
 <t>Efficient - Effective data compacting / compression support for plain binary and structured data</t>
</list>
</t>

</section>

<section anchor="motivation" title="Motivation">

<t>Project should provide universal protocol as a more feature-rich alternative to currently used binary protocols. It should provide general methods for handling various types of data including:

<list style="symbols">
 <t>Multimedia files - Audio, Video, Animation</t>
 <t>Filesystem structure - Allow to represent data in the form of filesystem or as compressed archive</t>
 <t>Application API - Remote or local methods execution supporting parameters and result passing</t>
 <t>Serialization protocol - Provide ability to serialize structured data</t>
 <t>Long-term storage - Provide way to define data with separate or integrated specification</t>
 <t>Huge data - Use dynamic numeric values to allow support for data in terabytes range or greater</t>
 <t>Segmented, paged, fragmented data</t>
 <t>Structural data for database representation</t>
 <t>Indexes, error detection and correction data</t>
</list>
</t>

<t>While there are various binary formats and markup languages available, this project aims to take somewhat different approach to data representation.</t>

<t>
<list style="symbols">
 <t>While SGML, XML and related technologies were huge inspiration for this project, it seems that it wouldn't be feasible to use them as base for the binary variant due to attribute vs. child tag duality and use of Unicode string as a primitive data type in contrast to countable set used by this project</t>

 <t>Using binary format is basically a necessity to make protocol reasonable usable for universal data like for example audio or video even thou text formats (for example JSON, YAML) provide easy of use and readability advantages</t>

 <t>Compare to wide range of existing binary formats with fixed block structure (for example RIFF), this project aims to provide more unified access to all data structures and their definitions</t>

 <t>Compare to formats based on serialization of data primitives (for example Protocol Buffers) this project aims to provide capability for data definitions which would make transmitting primitive types unnecessary</t>

 <t>Multi-level approach should allow to simplify and improve use compare to other dynamic binary formats (for example HDF5, ASN.1 and EBML)</t>
</list>
</t>

</section>

<section title="Terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
in this document are to be interpreted as described in
<xref target="RFC2119"/>.</t>

</section>
</section>

<section anchor="specification" title="XBUP Specification">

<t>XBUP is multi-layer protocol, where each layer is build on top of previous layer providing new capabilities (new features and/or constraints). Layers are indexed as levels by depth starting with level 0.</t>

<t>Applications can support only specific level of XBUP protocol when full support is not necessary.</t>

<texttable title="Layers">
  <preamble>Layers of the protocol</preamble>
  <ttcol>Level</ttcol><ttcol>Layer</ttcol>

  <c>0</c><c>Tree Structure</c>

  <c>1</c><c>Type System</c>

  <c>2</c><c>Transformations</c>

  <c>3</c><c>Relations</c>
</texttable>

<section anchor="level_0" title="Level 0: Tree Structure">

<t>Lowest protocol's level defines basic tree structure using two primitive types.</t>

<t>
<list style="symbols">

 <t>Attribute - Value encoded using UBNumber encoding</t>

 <t>Blob - Sequence of bits (bytes) with unspecified length or length specified by some attribute</t>
</list>
</t>

<t>Nodes are represented as one or more blocks of bits with child blocks representing child nodes of the tree.</t>

<section anchor="ubnumber_encoding" title="UBNumber Encoding">

<t>UBNumber is encoding which combines unary and binary encoding to represent values with dynamic length. It is typically representing natural non-negative integer number or value of any other type with deterministic mapping to countable set.</t>

<t>Encoding is similar to UTF-8, except that UBNumber is applied recursively when unary part fills all bits of the first byte.</t>

<t>To decode value, non-zero bits are counted for length up to 8 bits and then rest of bits is used as value. Value is also shifted so that there is only one code for each number.</t>

<t>Examples of the UBNatural - codes sequence of bits = value represented value in basic natural non-negative integer number:

<figure title="ALPS Contact Profile document">
 <artwork><![CDATA[
  0 0000000                                 = 0
  0 0000001                                 = 1
  0 0000010                                 = 2
  0 0000011                                 = 3
  ...
  0 1111111                                 = 7Fh = 127
  10 000000 | 00000000                      = 80h = 128
  10 000000 | 00000001                      = 81h = 129
  ...
  10 111111 | 11111111                      = 407Fh = 16511
  110 00000 | 00000000 | 00000000           = 4080h = 16512
  ...
]]></artwork>
</figure>
</t>

<t>Various interpretations can be mapped on UBNumber encoding. For level 0 following two mappings are used:

<list style="symbols">
 <t>UBNatural encoding using directly value from UBNumber basic mapping</t>

 <t>UBENatural where value 7Fh is reserved for infinity constant and higher values are shifted by one</t>
</list>
</t>

</section>

<section anchor="document" title="Document">

<t>For storing data in file to passing thru file, information about protocol version shall be included.</t>

<t>For version 0.2 of the document, data should start with fixed 6 bytes long data blob called "Document Header" followed by a single block called "Root Block" and any data after root block are optional blob called "Tail Data".</t>

<t>Header for current version of the protocol with hexadecimal codes. Explanation of the each value is non-conformant, primary use is padding to help systems which uses beginning of file for identification of file type.</t>

<texttable title="Header Bytes">
  <preamble>Structure of file header</preamble>
  
  <ttcol>Byte</ttcol><ttcol>Content</ttcol>

  <c>FE</c><c>Unary encoded size of cluster (byte)</c>
  <c>00</c><c>Reserved for future versions</c>
  <c>58</c><c>ASCII constant 'X'</c>
  <c>42</c><c>ASCII constant 'B'</c>
  <c>00</c><c>UBNatural encoded major version</c>
  <c>02</c><c>UBNatural encoded minor version</c>
</texttable>

<t>If header information is known thru the communication channel, document header can be omitted.</t>

</section>

<section anchor="block" title="Block">

<t>There are 3 kinds of blocks: Node Block, Data Block and Terminator</t>

<t>Each block starts with single attribute:

<figure title="">
 <artwork><![CDATA[
  UBNatural attributePartSize
]]></artwork>
</figure>
</t>

<t>If attributePartSize equals 0 then this block is called "Terminator" and block ends.</t>

<t>Otherwise it is followed by blob of the length specified by attributePartSize in bytes. Data in attribute part are interpreted as a sequence of attributes encoded in UBNumber encoding.</t>

<t>First attribute in attribute part represents value:

<figure title="">
 <artwork><![CDATA[
  UBENatural dataPartSize
]]></artwork>
</figure>
</t>

<t>If dataPartSize value fills exactly whole attribute part then this block is called "Data Block".</t>

<t>Binary blob called data part follows after attribute part and has length in bytes specified by dataPartSize value or if dataPartSize equals infinity bytes in data part are processed and when byte with value zero is used as escape code and, following byte represents how many bytes of zero it represents or end of the data part if it equals zero as well.</t>

<t>If dataPartSize value fills only part of the attribute part then this block is called "Node Block".</t>

<t>Binary blob called data part follows after attribute part. Data in data part are interpreted as a sequence of (child) blocks.</t>

<t>Data part has length in bytes specified by dataPartSize value or if dataPartSize equals infinity, sequence of blocks must be terminated by terminator block.</t>

<t>After data part block ends.</t>

<t>
<figure title="">
 <artwork><![CDATA[
  +---------------------------------------+
  | == First block's attribute ========== |
  |                                       |
  | UBNatural attributePartSize           |
  +---------------------------------------+
  | == Attribute part (optional) ======== |
  |                                       |
  | UBENatural dataPartSize               |
  | UBNumber attribute 1                  |
  | ...                                   |
  | UBNumber attribute n                  |
  +---------------------------------------+
  | == Data part (optional) ============= |
  |                                       |
  | Single data blob or child blocks      |
  +---------------------------------------+
]]></artwork>
</figure>
</t>
  
<t>See [block examples].</t>

</section>

<section anchor="validity" title="Validity">

<t>Binary stream is structured correctly as XBUP document (well-formed) if the following conditions are met. Description of invalid state is also included for each condition.</t>

<t>
<list style="symbols">
 <t>Optional: Stream header must be present (Corrupted or missing header)</t>

 <t>Optional: Header version must be in supported range (Unsupported version)</t>

 <t>In each block the end of last attribute corresponds to the end of the attribute part (Attribute overflow)</t>

 <t>In each block the end of last subblock corresponds to the end of the data block part (Block overflow)</t>

 <t>The terminal block is present only in blocks where it belongs to (Unexpected terminator)</t>

 <t>End of file is before the end of the root block (Unexpected end of data)</t>
</list>
</t>

</section>

</section>

<section anchor="level_1" title="Level 1: Block Types">

<t>Level 1 introduces block types and catalog of types. Since this level, if attribute is defined, but not present, it's value is considered as zero as in the form of UBNumber encoding.</t>

<section anchor="block_type" title="Block Type">

<t>First two attributes in node block are interpreted as follows (somewhat similar to XML Namespaces):</t>

<t>
<figure title="Block type attributes">
 <artwork><![CDATA[
  UBNatural - TypeGroup
  UBNatural - BlockType
]]></artwork>
</figure>
</t>

<t>These two values determines blocks type.</t>

<t>Block types are organized into groups where TypeGroup value specifies to which group block type belongs and BlockType value specifies particular block type in the corresponding group.</t>

<t>TypeGroup with value 0 is basic build-in group and cannot be overridden. Basic blocks provides ability to specify meaning of other groups via block type declarations, definitions or links to catalog or external source.</t>

</section>

<section anchor="type_context" title="Type Context">

<t>For each block, there is type context which provides mapping of particular block type (as defined above) to particular declaration/definition. Context is typically same for block and it's children, except for **declaration** block and it's **formatDeclaration** parameter, which affects context of **documentRoot** block and also incrementally affects group and block definitions which can use block types already defined in currently processed declaration.</t>

</section>

<section anchor="block_type_definition" title="Block Type Definition">

<t>Block type is defined as a finite sequence of operations where each operation defines one or more attributes and/or child blocks. Operation can define unspecified or refer build-in or previously defined types. There are variants for singular item and list of items, 8 operations in total:

<list style="symbols">
 <t>Single block - Single child block of any type.</t>

 <t>Single attribute - Single attribute of any type.</t>

 <t>Consist of definition - Single child block of referred type (as a component/element).</t>

 <t>Append definition - Appends all attributes and all child blocks of referred type.</t>

 <t>List of any blocks - One attribute of type UBENatural to define count of blocks of any type and child blocks of that count. When count equals infinity, list of blocks ends with empty block.</t>

 <t>List of attributes - One attribute of type UBNatural to define count of attributes of any type and attributes of that count.</t>

 <t>List of consist of definitions - One attribute of type UBENatural to define count of blocks of referred type and child blocks of that count. When count equals infinity, list of blocks ends with empty block.</t>

 <t>List of appended definitions - Appends one attribute of type UBNatural to define count of blocks of defined type and appends all attributes and all child blocks of referred type of that count.</t>
</list>
</t>

<t>Following syntax is used:</t>

<t>
<figure title="Block type attributes">
 <artwork><![CDATA[
  any - Single block
  attribute - Single attribute
  block_type_name - Consist of definition
  +block_type_name - Append definition
]]></artwork>
</figure>
</t>

<t>List variants of the operations ends with brackets "[]".</t>

</section>


</section>

</section>

<section anchor="out" title="Out">

<t>This is a reference to <xref target="RFC6949"/>.
Actually, the reference itself is not all that interesting, but the
way that the reference is incorporated is. Note that the inclusion
of RFC 2119 was done at the top of the XML, while the information
for RFC 6949 is done directly in the references section.</t>

<t>The <eref target="http://www.ietf.org">IETF web site</eref> is
<spanx style="emph">quite</spanx>
<spanx style="strong">nice</spanx>,
<spanx style="verb">isn't it</spanx>?
Unlike other web sites, it doesn't use
<vspace blankLines="2" />gratuitous vertical space.</t>

</section>

<section title="Basic Lists">

<t>Bulleted lists are good for items that
are not ordered:

<list style="symbols">

<t>This is the first item.</t>

<t>This is the second item. Here comes a sub-list:

<list style="symbols">

<t>This is the first sub-item.</t>

<t>This is the second sub-item<vspace/>
and some more detail on the second sub-item.</t>

</list></t>

<t>This is the item after the sub-list.</t>

</list></t>

<t>Numbered lists are good for items that are ordered:

<list style="numbers">

<t>This is the first item.</t>

<t>This is the second item. Here comes a sub-list, but
with letters:

<list style="letters">

<t>This is the first sub-item.</t>

<t>This is the second sub-item</t>

</list></t>

<t>This is the item after the sub-list.</t>

</list></t>

<t>And an example of hanging indent.

<list style="hanging" hangIndent="15">

<t hangText="Trees">These are bigger plants</t>

<t hangText="Lichen">These are smaller plants</t>

</list></t>

<t>And the always-interesting "format" for lists.

<list style="format --%d--">

<t>An element that gets a funny bullet.</t>

</list></t>

</section>

<section title="Figures">

<t>The following is a figure with a caption.
Also, it uses the ampersand (&amp;) and less than
(&lt;) characters in the example text.</t>

<figure title="This could be haiku" anchor="haiku">
<artwork type="haiku" align="left">
   The ampersand (&amp;) and
   less than (&lt;) are two characters
   that need escaping. 
</artwork>
</figure>

<t>Here are two short figures with no titles and with
odd alignment.</t>

<figure><artwork align="center">
This might appear in the center.
</artwork></figure>

<figure><artwork align="right">
This might appear right-aligned.
</artwork></figure>

<t>Here is a figure that is actually pulled from somewhere else.
<cref source="cs" anchor="rememberme">
Remember to check whether that file still exists.</cref></t>

<figure><artwork
  src="http://www.example.com/~employees/chrissmith/artwork.txt" />
</figure>

</section>

<section title="Tables">

<t>The following is a table example.</t>

<texttable title="The Noble Gases">
  <preamble>These are sometimes called "inert" gasses.</preamble>
  <ttcol>Name</ttcol>
  <ttcol align="center" width="50%">Symbol</ttcol>
  <ttcol align="center">Atomic Number</ttcol>

  <c>Helium</c>
  <c>He</c>
  <c>2</c>

  <c>Neon</c>
  <c>Ne</c>
  <c>10</c>

  <c>Argon</c>
  <c>Ar</c>
  <c>18</c>

  <c>Krypton</c>
  <c>Kr</c>
  <c>36</c>

  <c>Xenon</c>
  <c>Xe</c>
  <c>54</c>

  <c>Radon</c>
  <c>Rn</c>
  <c>86</c>

  <postamble>Source: Chemistry 101</postamble>
</texttable>

<t>The following is a right-aligned table with "full" (but not "all")
lines between cells.</t>

<texttable align="right" style="full">
  <ttcol>Time</ttcol>
  <ttcol align="right">Mood</ttcol>

  <c>Morning</c>
  <c>Happy!</c>

  <c>Afternoon</c>
  <c>Happy!</c>

  <c>Evening</c>
  <c>Somber</c>

</texttable>

</section>

<section anchor="IANA" title="IANA Considerations">

<t>None.</t>

</section>

<section anchor="Security" title="Security Considerations">

<t>There are no security considerations for an imaginary
Internet Draft.</t>

</section>

<section anchor="Acknowledgements" title="Acknowledgements">

<t>Some of the things included in this draft came from
Elwyn Davies' templates.</t>

<t>Something to note about this paragraph is that it has a
pointer to <xref target="specification"/>, and one to
<xref target="haiku"/>, both of which appear later in the
document.</t>

<iref item="Introduction" subitem="verbiage" primary="true"/>

</section>

</middle>

<back>

<references title="Normative References">

&RFC2119;

</references>

<references title="Informative References">

<reference anchor="RFC6949">
<front>
<title>RFC Series Format Requirements and Future Development</title>
<author initials="H." surname="Flanagan" fullname="H. Flanagan">
<organization/></author>
<author initials="N." surname="Brownlee" fullname="N. Brownlee">
<organization/></author>
<date year="2013" month="May"/>
</front>
<seriesInfo name="RFC" value="6949"/>
<annotation>This is a primary reference work.</annotation>
</reference>

<reference anchor="RED"
target="http://www.aciri.org/floyd/papers/early.pdf">
<front>
<title>Random Early Detection (RED) gateways for Congestion
Avoidance</title>
<author fullname="Sally Floyd" initials="S" surname="Floyd">
<organization>LBL</organization>
</author>
<author fullname="Van Jacobson" initials="V" surname="Jacobson">
<organization>LBL</organization>
</author>
<date month="August" year="1993"/>
</front>
<seriesInfo name="IEEE/ACM Transactions on Networking"
value="1(4) 397--413"/>
<format target="http://www.aciri.org/floyd/papers/early.pdf"
octets="318703" type="PDF"/>
</reference>

</references>

</back>
</rfc>