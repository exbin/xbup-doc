<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3117 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3117.xml">
<!ENTITY RFC4627 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY RFC7049 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7049.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc strict="yes" ?>

<rfc
  category="std"
  docName="draft-ietf-exbin-xbup-core-00"
  ipr="trust200902"
  consensus="no"
  submissionType="IETF"
  xml:lang="en"
>

<front>
<title abbrev="XBUP">
Extensible Binary Universal Protocol (XBUP)
</title>

<author fullname="Miroslav Hajda" surname="Hajda" initials="M.">
<organization>ExBin Project</organization>
<address>
<email>exbinproject@gmail.com</email>
<uri>https://exbin.org/</uri>
</address>
</author>

<date year="2020" month="June"/>

<area>General</area>
<workgroup>(TBD)</workgroup>
<keyword>Binary</keyword>
<keyword>Protocol</keyword>

<abstract>
<t>The Extensible Binary Universal Protocol (XBUP) is a prototype of general purpose binary data protocol and file format with primary focus on data abstraction and transformation.</t>
<t>This proposal describes specification of version 0.2 of bottom levels of the protocol and set of basic data types and the recommended API.</t>
</abstract>

<note title="Contributing">
<t>This document is being worked on by <eref target="https://exbin.org">ExBin Project</eref>, published here in order to gather comments and to raise interest in this project.</t>
<t>To participate on the development of this project, visit <eref target="https://xbup.exbin.org/?participate">https://xbup.exbin.org/?participate</eref>.</t>
</note>

</front>

<middle>

<section anchor="intro" title="Introduction">

<t>The Extensible Binary Universal Protocol (XBUP) is a prototype of general purpose multi-layer binary data protocol and file format with primary focus on abstraction and data transformation.</t>

<t>Key features:
<list style="symbols">
 <t>Unified block-tree structure - Minimalist tree structure based on integer and binary blob only</t>
 <t>Build-in and custom data types - Support for data type definitions and catalog of types</t>
 <t>Transformation framework - Automatic and manual data conversions and compatibility handling</t>
</list>
</t>

<t>Secondary features includes some capabilities inspired by markup languages like SGML/XML <xref target="XML"/> and data representation languages like YAML <xref target="YAML"/>, JSON <xref target="RFC4627"/> and similar binary formats like ASN.1 <xref target="ASN.1"/>, HDF5 <xref target="HDF5"/>, efficient XML <xref target="EfficientXML"/> or Protocol Buffers <xref target="ProtoBuf"/>.
<list style="symbols">
 <t>Extensibility</t>
 <t>Unconstrained values</t>
 <t>Internal and external referencing</t>
 <t>Data life-cycle / definition evolution</t>
</list>
</t>

<t>Primary focus on abstraction makes this protocol somewhat different compare to other similar binary formats which focus on efficiency, serialization or binary representation of a specific mark-up language. See <xref target="format_comparison">Formats comparison</xref> for more information.</t>

<t>This protocol technically overlaps in functionality with many currently widely used protocols and formats including those defined by various RFCs and is very different in nature compare to currently used internet protocols. Therefore it should be considered as somewhat discruptive and various aspects should be inspected, whether potential advantages this protocol could provide overweight complexity and complications it brings with, see <xref target="RFC3117"/> for design consideration.</t>

<section anchor="goals" title="Goals">

<t>The primary goal of this project is to create a communication protocol / data format with the following characteristics, ordered by priority:

<list style="symbols">
 <t>Universal - Capable of representation of any type of data, suitable for wide use including streaming, long-term storage and parallel accessing</t>
 <t>Independent - Not tightly linked to a particular spoken language, product, company, processing architecture or programming language</t>
 <t>Declarative - Self sufficient for data type definition and with the ability to build data types on top of each other and to combine them together</t>
 <t>Normative - Providing reference form for data representation</t>
 <t>Flexible - Support for data transformations, compatibility and extensibility handling</t>
 <t>Efficient - Effective data compacting / compression support for plain binary and structured data</t>
</list>
</t>

</section>

<section anchor="motivation" title="Motivation">

<t>Project should provide universal protocol as a more feature-rich alternative to currently used binary protocols. It should provide general methods for handling data of various character and types including:

<list style="symbols">
 <t>Multimedia files - Audio, video, animation, 3D</t>
 <t>Filesystem structure - Allow to represent data in the form of filesystem or as a compressed archive</t>
 <t>Application API - Remote or local method call execution, supporting parameters and result passing and error handling</t>
 <t>Serialization protocol - Provide ability to serialize non-structured data</t>
 <t>Huge data - Use dynamic numeric values to allow support for data in terabytes range or greater</t>
 <t>Random access - Segmented, paged, fragmented data</t>
 <t>Parallel processing - Atomicity, structural data for database representation</t>
 <t>Indexes, error detection and data correction</t>
</list>
</t>

<t>From the users point of view, protocol should provide new capabilities or enable new development in various areas:

<list style="symbols">
 <t>Browseable binary content - Provide capability for viewing and editation of data, including visual and graphical tools and textual tools with multiple available syntaxes and supported languages</t>
 <t>Strong building blocks - Provide well specified data representation and ability to construct even complex data structures from combining data type definitions from wide libraries</t>
 <t>Flexible modular applications - With the ability to provide both independent API and data interchange format and with automatic transformation between both of them, it should be possible to utilize the protocol to enhance approach for modular applications design</t>
 <t>Long-term storage - Provide way to define data with external or integrated specification</t>
 <t>Comprehensive scientific protocol - With the multiple levels of expresiveness and capability to define unlimited number of additional properties, it should be possible to utilize the protocol for definition and storage of specialized scientific data</t>
</list>
</t>

</section>

<section anchor="terminology" title="Terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
in this document are to be interpreted as described in
<xref target="RFC2119"/>.</t>

<t>The term "byte" is used in its now-customary sense as a synonym for "octet" - sequence of 8 bits.</t>
   
</section>
</section>

<section anchor="specification" title="XBUP Specification">

<t>XBUP is multi-layer protocol for representation of data in bit/byte stream, where each layer is build on top of previous layer providing new capabilities, like new constraints and/or features. Typically, higher levels also declare back entities used in lower levels.</t>

<t>Applications can support only up to specific level of XBUP protocol when full support is not necessary.</t>

<t>Layers are indexed as levels by depth starting with level 0.</t>

<texttable title="Layers">
  <preamble>Layers of the protocol</preamble>
  <ttcol>Level</ttcol><ttcol>Layer</ttcol>

  <c>0</c><c>Tree Structure</c>

  <c>1</c><c>Type System</c>

  <c>2</c><c>Transformations</c>

  <c>3</c><c>Relations</c>
</texttable>

<section anchor="level_0" title="Level 0: Tree Structure">

<t>Lowest protocol's level defines basic tree structure using two primitive types.</t>

<t>
<list style="symbols">

 <t>UBNumber encoded value</t>

 <t>Blob - Sequence of bits (bytes) with unspecified length or length specified by some attribute</t>
</list>
</t>

<t>Nodes are represented as one or more blocks of bits with child blocks representing child nodes of the tree.</t>

<section anchor="ubnumber_encoding" title="UBNumber Encoding">

<t>UBNumber is encoding which combines unary and binary encoding to represent values with dynamic length. It is typically representing natural non-negative integer number (or value of any other type with deterministic mapping to well ordered / countably infinite set).</t>

<t>Encoding is similar to UTF-8, except that UBNumber is applied recursively when unary part fills all bits of the first byte.</t>

<t>To decode value, non-zero bits are counted for length up to 8 bits and then rest of bits is used as value. Value is also shifted so that there is only one code for each number.</t>

<t>Examples of the UBNatural - codes sequence of bits = value represented value in basic natural non-negative integer number:</t>

<figure title="UBNumber codes and values">
 <artwork><![CDATA[
  0 0000000                                 = 0
  0 0000001                                 = 1
  0 0000010                                 = 2
  0 0000011                                 = 3
  ...
  0 1111111                                 = 7Fh = 127
  10 000000 | 00000000                      = 80h = 128
  10 000000 | 00000001                      = 81h = 129
  ...
  10 111111 | 11111111                      = 407Fh = 16511
  110 00000 | 00000000 | 00000000           = 4080h = 16512
  ...
]]></artwork>
</figure>

<t>Various interpretations can be mapped on UBNumber encoding. For level 0 following two mappings are used:

<list style="symbols">
 <t>UBNatural encoding using directly value from UBNumber basic mapping</t>

 <t>UBENatural where value 7Fh is reserved for infinity constant and higher values are shifted by one</t>
</list>
</t>

</section>

<section anchor="document" title="Document">

<t>Single document is typically represented as a single block, but there can be additional optional tail data present.</t>

<t>To store document in the file in file system or for use in the undeclared data stream, additional "Document header" should be present.</t>

<t>Document header contains information about protocol version shall be included. For the version 0.2 of the protocol, it is 6 bytes long data blob. Explanation of the each value is non-conformant, primary use is padding to help systems which uses beginning of file for identification of file type.</t>

<t>Document header with hexadecimal values:</t>

<texttable title="Document Header Bytes">
  <preamble>Structure of file header</preamble>
  
  <ttcol>Byte</ttcol><ttcol>Content</ttcol>

  <c>FE</c><c>Unary encoded size of cluster (byte)</c>
  <c>00</c><c>Reserved for future versions</c>
  <c>58</c><c>ASCII constant 'X'</c>
  <c>42</c><c>ASCII constant 'B'</c>
  <c>00</c><c>UBNatural encoded major version</c>
  <c>02</c><c>UBNatural encoded minor version</c>
</texttable>

<t>Primary block called "Root Block" follows and any data after root block are optional blob called "Tail Data".</t>

</section>

<section anchor="block" title="Block">

<t>Each block starts with single value:</t>

<figure title="">
 <artwork><![CDATA[
  UBNatural attributePartSize
]]></artwork>
</figure>

<t>Value attributePartSize is not allowed to equal 0 for the block as it is used for "Terminator" handling (see below).</t>

<t>Block continues with attribute part which is blob of the length specified by attributePartSize in bytes.</t>

<t>First value in attribute part represents:</t>

<figure title="">
 <artwork><![CDATA[
  UBENatural dataPartSize
]]></artwork>
</figure>

<t>Rest of the data (if any) in the attribute part is interpreted as a nonempty sequence of attribute values encoded in any UBNumber encoding. Binary blob called data part follows after attribute part (is optional / could be empty).</t>

<t>If the dataPartSize value fills exactly whole attribute part (there is exactly zero attributes in attribute part) then this block is called "Data Block" else block is called "Node Block".</t>

<t>After data part block ends.</t>

<figure title="">
 <artwork><![CDATA[
  +-------------------------------------+
  | == Block ========================== |
  |                                     |
  | UBNatural attributePartSize         |
  +-------------------------------------+
  | == Attribute part ================= |
  |                                     |
  | UBENatural dataPartSize             |
  | UBNumber attribute 1                |
  | ...                                 |
  | UBNumber attribute n                |
  +-------------------------------------+
  | == Data part (optional) =========== |
  |                                     |
  | Single data blob or child blocks    |
  +-------------------------------------+
]]></artwork>
</figure>

<t>Effectively, transferred data are represented by a sequence of attributes and child blocks or data blob, while attributePartSize and dataPartSize values are present for the structural purpose.</t>

<t>See <xref target="examples_of_blocks">examples of blocks</xref>.</t>

</section>

<section anchor="node_block" title="Node Block">

<t>When there is at least one attribute value in attribute part, block is called node block. Data in data part are interpreted as a sequence of (child) blocks.</t>

<t>Data part has length in bytes specified by dataPartSize value or if dataPartSize equals infinity, sequence of child blocks must be infinite or terminated by terminator (single zero byte value).</t>

<t>If there are no child blocks, block is called leaf block.</t>

</section>

<section anchor="data_block" title="Data Block">

<t>When there is no attribute value in attribute part, block is called data block. Data in data part are interpreted as a binary blob.</t>

<t>Data part has length in bytes specified by dataPartSize value or if dataPartSize equals infinity, data part is processed by byte and each value zero is used as a escape code, where directly following byte means:

<list style="symbols">
<t>Value 0 denotes end of the data part</t>
<t>Value 1 to 255 denotes sequence of zero bytes of given count and processing continues</t>
</list>
</t>

<t>If there are data in data part, block is called empty block.</t>

</section>

<section anchor="validity" title="Validity">

<t>Binary stream is structured correctly as XBUP document (well-formed) if the following conditions are met. Description of invalid state is also included for each condition.</t>

<t>
<list style="symbols">
 <t>Optional: Stream header must be present (Corrupted or missing header)</t>

 <t>Optional: Header version must be in supported range (Unsupported version)</t>

 <t>In each block the end of last attribute corresponds to the end of the attribute part (Attribute overflow)</t>

 <t>In each block the end of last subblock/child block corresponds to the end of the data part (Block overflow)</t>

 <t>The terminal block is present only in blocks where it belongs to (Unexpected terminator)</t>

 <t>End of file is before the end of the root block (Unexpected end of data)</t>
</list>
</t>

</section>

</section>

<section anchor="level_1" title="Level 1: Block Types">

<t>Level 1 introduces block types and catalog of types. Since this level, if attribute is defined, but not present, it's value is considered as zero as in the form of UBNumber encoding.</t>

<section anchor="block_type" title="Block Type">

<t>First two attributes in node block are interpreted as follows (somewhat similar to XML Namespaces):</t>

<figure title="Block type attributes">
 <artwork><![CDATA[
  UBNatural - TypeGroup
  UBNatural - BlockType
]]></artwork>
</figure>

<t>These two values determines block type. Block types are organized into groups where TypeGroup value specifies to which group block type belongs and BlockType value specifies particular block type in the corresponding group.</t>

<t>TypeGroup with value 0 is basic build-in group and cannot be overridden. Basic blocks provides ability to specify meaning of other groups via block type declarations, definitions or links to catalog or external source.</t>

</section>

<section anchor="type_context" title="Type Context">

<t>For each block, there is type context which provides mapping of particular block type (as defined above) to particular declaration/definition (similar to XML Namespaces context). Context is the same for block and all it's children, except for "Document Declaration" block which is used to change context.</t>

<t>Range of groups and range of blocks for each group is speficied.</t>

</section>

<section anchor="block_type_definition" title="Block Type Definition">

<t>Block type is defined as a finite sequence of operations where each operation defines one or more attributes and/or child blocks. Operation can define unspecified or refer build-in or previously defined types. There are variants for singular item and list of items, 8 operations in total:

<list style="symbols">
 <t>Single block - Single child block of any type.</t>

 <t>Single attribute - Single attribute of any type.</t>

 <t>Consist of definition - Single child block of referred type (as a component/element).</t>

 <t>Append definition - Appends all attributes and all child blocks of referred type.</t>

 <t>List of any blocks - One attribute of type UBENatural to define count of blocks of any type and child blocks of that count. When count equals infinity, list of blocks ends with empty block.</t>

 <t>List of attributes - One attribute of type UBNatural to define count of attributes of any type and attributes of that count.</t>

 <t>List of consist of definitions - One attribute of type UBENatural to define count of blocks of referred type and child blocks of that count. When count equals infinity, list of blocks ends with empty block.</t>

 <t>List of appended definitions - Appends one attribute of type UBNatural to define count of blocks of defined type and appends all attributes and all child blocks of referred type of that count.</t>
</list>
</t>

<t>Following syntax is used in this document (no final syntax is decided yet):</t>

<figure title="Block type attributes">
 <artwork><![CDATA[
  any - Single block
  attribute - Single attribute
  block_type_name - Consist of definition
  +block_type_name - Append definition
]]></artwork>
</figure>

<t>List variants of the operations ends with brackets "[]" after type name.</t>

<t>From the abstraction perspective (more about <xref target="abstraction">abstraction</xref>) type definition as data definition is in default mode done using consist operation (as child blocks), this allows to define data type as set of singular child types or sets of child types including infinite number of them, but additionaly members must be well ordered (list). Join operation is from this point of view doesn't change much, except it's restricted to finite sets.</t>  

</section>

<section anchor="basics" title="Basic Blocks Definition">

<t>Following blocks are defined as build-in group 0, but also defined in catalog.</t>

<section anchor="basic_unspecified" title="Unspecified (0)">

<t>This block is used for unspecified block values or data padding. Can be used to represent nil / null values.</t>

</section>

<section anchor="basic_document_declaration" title="Document Declaration (1)">

<t>Declaration block determines the allowed range of groups. This block should be located at the beginning of each file, if the application didn't provide any static/special meaning, but it might be used anywhere inside document as well.</t>

<figure title="Document Declaration">
 <artwork><![CDATA[
  +Natural groupsCount - The number of allocated groups
  +Natural preserveGroups - The number of groups to keep from
    previous declarations
  FormatDeclaration formatDeclaration - Declaration of format
  Any documentRoot - Root node of document
]]></artwork>
</figure>

<t>For subblocks of this block there is permitted range of values in the interval group preserveGroups + 1 .. preserveGroups + groupsCount + 1. preservedGroups + groupsCount + 1. If the value reserveGroups = 0, takes the highest not yet reserved group in the current or parental blocks + 1. For all values of zero and the application of rules of cutting the block of zeros coincides with the data block.</t>

</section>

<section anchor="basic_format_declaration" title="Format Declaration (2)">

<t>Format declaration allows you use either declaration from catalog or local format definition or both.</t>

<figure title="Format Declaration">
 <artwork><![CDATA[
  +CatalogFormatSpecPath catalogFormatSpecPath - Specification
    of format defined as path in catalog
  +Natural formatSpecRevision - Specification's revision number
  FormatDefinition formatDefinition
]]></artwork>
</figure>

</section>

<section anchor="basic_format_definition" title="Format Definition (3)">

<t>This block allows to specify the basic structure of format specification. Specifies the sequence of parameters using either join or consist operation.</t>

<figure title="Format Definition">
 <artwork><![CDATA[
  Any[] formatParameters - Join or Consist format parameters
  +RevisionDefinition[] revisions
]]></artwork>
</figure>

</section>

<section anchor="basic_format_join_parameter" title="Format Join Parameter (4)">

<t>Join parameter for format definition.</t>

<figure title="Format Join Parameter">
 <artwork><![CDATA[
  +FormatDeclaration formatDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_format_consist_parameter" title="Format Consist Parameter (5)">

<t>Consist parameter for format definition.</t>

<figure title="Format Consist Parameter">
 <artwork><![CDATA[
  +GroupDeclaration groupDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_group_declaration" title="Group Declaration (6)">

<t>Group declaration allows you use either declaration from catalog or local group definition or both.</t>

<figure title="Group Declaration">
 <artwork><![CDATA[
  +CatalogGroupSpecPath catalogGroupSpecPath - Specification
    of format defined as path in catalog
  +Natural groupSpecRevision - Specification's revision number
  GroupDefinition groupDefinition
]]></artwork>
</figure>

</section>

<section anchor="basic_group_definition" title="Group Definition (7)">

<t>This block allows to specify the basic structure of group specification. Specifies the sequence of parameters using either
join or consist operation.</t>

<figure title="Group Definition">
 <artwork><![CDATA[
  Any[] groupParameters - Join or Consist group parameters
  +RevisionDefinition[] revisions
]]></artwork>
</figure>

</section>

<section anchor="basic_group_join_parameter" title="Group Join Parameter (8)">

<t>Join parameter for group definition.</t>

<figure title="Group Join Parameter">
 <artwork><![CDATA[
  +GroupDeclaration groupDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_group_consist_parameter" title="Group Consist Parameter (9)">

<t>Consist parameter for group definition.</t>

<figure title="Group Consist Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_block_declaration" title="Block Declaration (10)">

<t>Block declaration allows you use either declaration from catalog or local block definition or both.</t>

<figure title="Block Declaration">
 <artwork><![CDATA[
  +CatalogBlockSpecPath catalogBlockSpecPath - Specification
    of format defined as path in catalog
  +Natural blockSpecRevision - Specification's revision number
  BlockDefinition blockDefinition
]]></artwork>
</figure>

</section>

<section anchor="basic_block_definition" title="Block Definition (11)">

<t>This block allows to specify the basic structure of block specification. Specifies the sequence of parameters using either join, consist, list join or list consist operation.</t>

<figure title="Block Definition">
 <artwork><![CDATA[
  Any[] blockParameters - Join or Consist or List Join or List
    Consist block parameters
  +RevisionDefinition[] revisions
]]></artwork>
</figure>

</section>

<section anchor="basic_block_join_parameter" title="Block Join Parameter (12)">

<t>Join parameter for block definition.</t>

<figure title="Block Join Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_block_consist_parameter" title="Block Consist Parameter (13)">
  
<t>Consist parameter for block definition.</t>

<figure title="Block Consist Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_block_list_join_parameter" title="Block List Join Parameter (14)">

<t>List join parameter for block definition.</t>

<figure title="Block List Join Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_block_list_consist_parameter" title="Block List Consist Parameter (15)">

<t>List consist parameter for block definition.</t>

<figure title="Block List Consist Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_revision_definition" title="Revision Definition (16)">

<t>Revision allows to define parameters count for particular specification definition.</t>

<figure title="Revision Definition">
 <artwork><![CDATA[
  +Natural parametersCount
]]></artwork>
</figure>

</section>

</section>

<section anchor="main_catalog" title="Main Catalog">

<t>To specify basic data types, catalog of block type definitions is established.</t>

<t>Catalog is structured as a tree of definitions, where each block type has a unique identifier (sequence of natural numbers). Tree nodes are denoted by ownership base and are suppose to follow similar pattern like internet domain names.</t>

<t>Additional to block, group and format specifications, catalog can contain basically any other data which will be properly specified on further protocol levels, for example:

<list style="symbols">

<t>Name of the type in multiple languages</t>
<t>Documentation for given type</t>
<t>Icon</t>
<t>Author / ownership</t>
<t>Custom viewer/editor</t>

</list>
</t>

<t>For basic access, catalog should be accesible as single document stored in XBUP format.</t>

</section>

<section anchor="additional_catalog" title="Additional Catalog">

<t>Additional catalogs can be addressed from external sources.</t>

</section>

</section>

<section anchor="level_2" title="Level 2: Transformations">

<t>In general, block transformation is data flow from one block type to another block type (more about <xref target="abstraction">abstraction</xref>). Transformation can be used for multiple tasks and cover various operations with data.</t>

<t>This level introduces capability to define transformations in catalog and automatically performs conversion between blocks.</t>

<t>Transformations can be also used for:

<list style="symbols">

<t>Paging</t>
<t>Compression</t>
<t>Encryption</t>
<t>Specify operation between multiple blocks</t>
<t>TODO</t>

</list>
</t>

<t>TODO</t>

</section>

<section anchor="level_3" title="Level 3: Ontologies">

<t>Following level can additionaly specify more about meaning of the data:

<list style="symbols">

<t>Restrict number of items in list</t>
<t>Restrict type of any type</t>
<t>Specify restricted document structure</t>
<t>Specify relations between blocks</t>

</list>
</t>

</section>

<section anchor="data_types" title="Data Types">

<t>Following section defines various data types considered for specification in catalog.</t> 

<section anchor="type_natural" title="Natural">

<t>Natural type for UBNumber encoding is to use non-negative integer mapping.</t>

</section>

<section anchor="type_integer" title="Integer">

<t>Integer type is stored in UBNumber encoding using 2-complement form similar to how it is used in computing.</t>

</section>

</section>

</section>

<section anchor="appendixes" title="Appendixes">

<section anchor="examples_of_blocks" title="Examples of Blocks">

<t>Fixed size node block with one attribute</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>02</c><c>AttributePartSize</c>
  <c>00</c><c>DataPartSize</c>
  <c>77</c><c>Attribute 1 of value 0x77</c>
</texttable>

<t>Terminated node block with one attribute</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>02</c><c>AttributePartSize</c>
  <c>7F</c><c>DataPartSize</c>
  <c>05</c><c>Attribute 1</c>
  <c>00</c><c>Terminator</c>
</texttable>

<t>Fixed size data block</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>01</c><c>AttributePartSize</c>
  <c>01</c><c>DataPartSize</c>
  <c>BB</c><c>One byte of data 0xBB</c>
</texttable>

<t>Terminated empty data block</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>01</c><c>AttributePartSize</c>
  <c>7F</c><c>DataPartSize</c>
  <c>00</c><c>Data block escape</c>
  <c>00</c><c>Termination value</c>
</texttable>

<t>Fixed block with one child</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>02</c><c>AttributePartSize</c>
  <c>03</c><c>DataPartSize</c>
  <c>66</c><c>Attribute 1 of value 0x66</c>
  <c>  02</c><c>AttributePartSize</c>
  <c>  00</c><c>DataPartSize</c>
  <c>  77</c><c>Attribute 1 of value 0x77</c>
</texttable>

</section>

<section anchor="abstraction" title="Appendix 1: Abstraction">

<t>Concept of data used in this protocol is using set theory, where set must be countable as well for each member of data there must exist mapping to well-ordered countable set.</t>

<t>At the same time data definitions are similar to table columns definition used in relation databases, except that infinite number of items is also supported.</t>

<t>Protocol processing is based on broad concept of dataflow paradigm, which typically state that there are input data, process and output data.</t>

<t>Additional requirement here is, that process must be deterministic (for same input return the same output), but other than that, it can be run in any manner - from local function in memory up to remote process in cloud.</t>

</section>

<section anchor="parsing" title="Appendix 2: Parsing">

<t>Similar to parsing of textual formats, it's possible to provide parsing capability for binary protocol.

<list style="symbols">
<t>Object Model Parsing</t>
<t>Pull Parsing</t>
<t>Event Parsing</t>
<t>Hybrid Approaches</t>
</list>

</t>

<section anchor="appendix_parsing_level_0" title="Level 0 Parsing">

<t>To process level 0 protocol following 4 types of tokens are used:

<list style="symbols">

 <t>begin (terminationMode flag)</t>
 <t>attribute (UBNumber value)</t>
 <t>data (Binary data)</t>
 <t>end</t>

</list>
</t>

<t>Following simplified grammar can be used for token processing.</t>

<t>
<figure title="Simplified grammar">
 <artwork><![CDATA[
  Document ::= header + Block + data
  Block ::= begin + Attributes + Blocks + end | begin + data + end
  Blocks ::= Block + Blocks | epsilon
  Attributes ::= attribute + Attributes | epsilon
]]></artwork>
</figure>
</t>

</section>

</section>

<section anchor="format_comparison" title="Appendix 3: Format Comparison">

<t>While there are various binary formats and markup languages available, this project aims to take somewhat different approach to data representation.</t>

<t>
<list style="symbols">
 <t>While SGML, XML <xref target="XML"/> and related technologies were huge inspiration for this project, it seems that it wouldn't be feasible to use them as base for the binary variant due to attribute vs. child tag duality and use of Unicode string as a primitive data type in contrast to countable set used by this project</t>

 <t>Using binary format is basically a necessity to make protocol reasonable usable for universal data like for example audio or video even thou text formats (for example JSON <xref target="RFC4627"/>, YAML <xref target="YAML"/>) provide easy of use and readability advantages</t>

 <t>Compare to wide range of existing binary formats with fixed block structure (for example RIFF), this project aims to provide more unified access to all data structures and their definitions</t>

 <t>Compare to formats based on serialization of data primitives (for example Protocol Buffers <xref target="ProtoBuf"/>, CBOR <xref target="RFC7049"/>) this project aims to provide capability for data definitions which would make transmitting primitive types unnecessary</t>

 <t>Multi-level approach should allow to simplify and improve use compare to other dynamic binary formats (for example HDF5 <xref target="HDF5"/>, ASN.1 <xref target="ASN.1"/> and EBML <xref target="EBML"/>)</t>
</list>
</t>

</section>

</section>

<section anchor="IANA" title="IANA Considerations">

<t>In the current early state of the development of the protocol, just basic media type for general files is defined: application/x-xbup</t>

</section>

<section anchor="Security" title="Security Considerations">

<t>Security was not considered at current level of the development.</t>

</section>

<section anchor="Acknowledgements" title="Acknowledgements">

<t>TBD</t>

<iref item="Introduction" subitem="verbiage" primary="true"/>

</section>

</middle>

<back>

<references title="Normative References">

&RFC2119;

</references>

<references title="Informative References">

&RFC3117;

&RFC4627;

&RFC7049;

<reference anchor="ASN.1" target="https://www.itu.int/rec/T-REC-X.690">
  <front>
    <title>Information Technology -- ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
    <author fullname="International Telecommunication Union"/>
    <date year="1994"/>
  </front>
  <annotation>ITU-T Recommendation X.690</annotation>
</reference>

<reference anchor="YAML" target="http://www.yaml.org/spec/1.2/spec.html">
  <front>
    <title>YAML Ain't Markup Language (YAML[TM]) Version 1.2, 3rd Edition</title>
    <author initials="O." surname="Ben-Kiki" fullname="Oren Ben-Kiki"/>
    <author initials="C." surname="Evans" fullname="Clark Evans"/>
    <author initials="I." surname="Net" fullname="Ingy dot Net"/>
    <date year="2009" month="October"/>
  </front>
</reference>

<reference anchor="XML" target="https://www.w3.org/TR/2008/REC-xml-20081126/">
  <front>
    <title>Extensible Markup Language (XML) 1.0 (Fifth Edition)</title>
    <author initials="T." surname="Bray" fullname="Tim Bray"/>
    <author initials="J." surname="Paoli" fullname="Jean Paoli"/>
    <author initials="C. M." surname="Sperberg-McQueen" fullname="C. M. Sperberg-McQueen"/>
    <author initials="E." surname="Maler" fullname="Eve Maler"/>
    <author initials="F." surname="Yergeau" fullname="Francois Yergeau"/>
    <date year="2008" month="November"/>
  </front>
  <annotation>W3C Recommendation REC-xml-20081126</annotation>
</reference>

<reference anchor="EfficientXML" target="https://www.w3.org/TR/2014/REC-exi-20140211/">
  <front>
    <title>Efficient XML Interchange (EXI) Format 1.0 (Second Edition)</title>
    <author initials="J." surname="Schneider" fullname="John Schneider"/>
    <author initials="T." surname="Kamiya" fullname="Takuki Kamiya"/>
    <author initials="D." surname="Peintner" fullname="Daniel Peintner"/>
    <author initials="R." surname="Kyusakov" fullname="Rumen Kyusakov"/>
    <date year="2014" month="February"/>
  </front>
</reference>

<reference anchor="HDF5" target="https://support.hdfgroup.org/HDF5/doc/H5.format.html">
  <front>
    <title>HDF5 File Format Specification Version 3.0</title>
    <author fullname="The HDF Group"/>
    <date year="2016" month="April"/>
  </front>
</reference>

<reference anchor="EBML" target="https://datatracker.ietf.org/doc/draft-ietf-cellar-ebml/">
  <front>
    <title>Extensible Binary Meta Language</title>
    <author initials="S." surname="Lhomme" fullname="Steve Lhomme" />
    <author initials="D." surname="Rice" fullname="Dave Rice" />
    <author initials="M." surname="Bunkus" fullname="Moritz Bunkus"/>
    <date year="2020"/>
  </front>
  <seriesInfo name='Work in Progress,' value='draft-ietf-cellar-ebml'/>
</reference>

<reference anchor="IEEE.754.1985" target="">
  <front>
    <title>Standard for Binary Floating-Point Arithmetic</title>
    <author>
      <organization>Institute of Electrical and Electronics Engineers</organization>
    </author>
    <date year="1985" month="August"></date>
  </front>
</reference>

<reference anchor="ProtoBuf" target="https://developers.google.com/protocol-buffers/">
  <front>
    <title>Protocol Buffers</title>
    <author>
      <organization>Google</organization>
    </author>
    <date year="2020"></date>
  </front>
</reference>

</references>

</back>
</rfc>