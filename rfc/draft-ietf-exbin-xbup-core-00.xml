<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM
  "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc strict="yes" ?>

<rfc
  category="std"
  docName="draft-ietf-exbin-xbup-core-00"
  ipr="trust200902"
  consensus="no"
  submissionType="IETF"
  xml:lang="en"
>

<front>
<title abbrev="XBUP">
Extensible Binary Universal Protocol (XBUP)
</title>

<author fullname="Miroslav Hajda" surname="Hajda" initials="M.">
<organization>ExBin Project</organization>
<address>
<email>exbinproject@gmail.com</email>
<uri>https://exbin.org/</uri>
</address>
</author>

<date year="2020" month="March"/>

<area>General</area>
<workgroup>(TBD)</workgroup>
<keyword>Binary</keyword>
<keyword>Protocol</keyword>

<abstract>
<t>The Extensible Binary Universal Protocol (XBUP) is a prototype of general purpose binary data protocol and file format with primary focus on data abstraction and transformation.</t>
<t>This proposal describes specification of version 0.2 of bottom levels of the protocol and set of basic data types and the recommended API.</t>
</abstract>

<note title="Contributing">
<t>This document is being worked on by ExBin Project, aiming to gather comments and to raise interest in this project.</t>
<t>To participate on the development of this project, visit <eref target="https://xbup.exbin.org/?participate">https://xbup.exbin.org/?participate</eref>.</t>
</note>

</front>

<middle>

<section anchor="intro" title="Introduction">

<t>The Extensible Binary Universal Protocol (XBUP) is a prototype of general purpose multi-layer binary data protocol and file format with primary focus on abstraction and data transformation.</t>

<t>Key features:
<list style="symbols">
 <t>Unified block-tree structure - Minimalist tree structure based on integer and binary blob only</t>
 <t>Build-in and custom data types - Support for data type definitions and catalog of types</t>
 <t>Transformation framework - Automatic and manual data conversions and compatibility handling</t>
</list>
</t>

<t>Secondary features includes some capabilities inspired by markup languages like SGML/XML and data representation languages like YAML, JSON [RFC4627] and similar binary formats like ASN.1, HDF5 and efficient XML.
<list style="symbols">
 <t>Extensibility</t>
 <t>Unconstrained values</t>
 <t>Internal and external referencing</t>
 <t>Data life-cycle / definition evolution</t>
</list>
</t>

<t>Primary focus on abstraction makes this protocol somewhat different compare to other similar binary formats which focus on efficiency, serialization or binary representation of specific mark-up language. See "Formats comparison" section for more information about this topic.</t>

<section anchor="goals" title="Goals">

<t>The primary goal of this project is to create a communication protocol / data format with the following characteristics, ordered by priority:

<list style="symbols">
 <t>Universal - Capable of representation of any type of data, suitable for wide use including streaming, long-term storage and parallel access</t>
 <t>Independent - Not tightly linked to a particular spoken language, product, company, processing architecture or programming language</t>
 <t>Declarative - Self sufficient for data type definition and with ability to build data types on top of each other and to combine them together</t>
 <t>Normative - Providing reference form for data representation</t>
 <t>Flexible - Support for data transformations, compatibility and extensibility handling</t>
 <t>Efficient - Effective data compacting / compression support for plain binary and structured data</t>
</list>
</t>

</section>

<section anchor="motivation" title="Motivation">

<t>Project should provide universal protocol as a more feature-rich alternative to currently used binary protocols. It should provide general methods for handling data of various character and types including:

<list style="symbols">
 <t>Multimedia files - Audio, video, animation, 3D</t>
 <t>Filesystem structure - Allow to represent data in the form of filesystem or as a compressed archive</t>
 <t>Application API - Remote or local method call execution, supporting parameters and result passing and error handling</t>
 <t>Serialization protocol - Provide ability to serialize structured data</t>
 <t>Long-term storage - Provide way to define data with external or integrated specification</t>
 <t>Huge data - Use dynamic numeric values to allow support for data in terabytes range or greater</t>
 <t>Random access - Segmented, paged, fragmented data</t>
 <t>Parallel processing - Atomicity, structural data for database representation</t>
 <t>Indexes, error detection and data correction</t>
</list>
</t>

<t>While there are various binary formats and markup languages available, this project aims to take somewhat different approach to data representation.</t>

<t>
<list style="symbols">
 <t>While SGML, XML and related technologies were huge inspiration for this project, it seems that it wouldn't be feasible to use them as base for the binary variant due to attribute vs. child tag duality and use of Unicode string as a primitive data type in contrast to countable set used by this project</t>

 <t>Using binary format is basically a necessity to make protocol reasonable usable for universal data like for example audio or video even thou text formats (for example JSON, YAML) provide easy of use and readability advantages</t>

 <t>Compare to wide range of existing binary formats with fixed block structure (for example RIFF), this project aims to provide more unified access to all data structures and their definitions</t>

 <t>Compare to formats based on serialization of data primitives (for example Protocol Buffers, CBOR) this project aims to provide capability for data definitions which would make transmitting primitive types unnecessary</t>

 <t>Multi-level approach should allow to simplify and improve use compare to other dynamic binary formats (for example HDF5, ASN.1 and EBML)</t>
</list>
</t>

</section>

<section title="Terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
in this document are to be interpreted as described in
<xref target="RFC2119"/>.</t>

</section>
</section>

<section anchor="specification" title="XBUP Specification">

<t>XBUP is multi-layer protocol for representation of data in bit/byte stream, where each layer is build on top of previous layer providing new capabilities (new constraints and/or features).</t>

<t>Applications can support only specific level of XBUP protocol when full support is not necessary.</t>

<t>Layers are indexed as levels by depth starting with level 0.</t>

<texttable title="Layers">
  <preamble>Layers of the protocol</preamble>
  <ttcol>Level</ttcol><ttcol>Layer</ttcol>

  <c>0</c><c>Tree Structure</c>

  <c>1</c><c>Type System</c>

  <c>2</c><c>Transformations</c>

  <c>3</c><c>Relations</c>
</texttable>

<section anchor="level_0" title="Level 0: Tree Structure">

<t>Lowest protocol's level defines basic tree structure using two primitive types.</t>

<t>
<list style="symbols">

 <t>Attribute - Value encoded using UBNumber encoding</t>

 <t>Blob - Sequence of bits (bytes) with unspecified length or length specified by some attribute</t>
</list>
</t>

<t>Nodes are represented as one or more blocks of bits with child blocks representing child nodes of the tree.</t>

<section anchor="ubnumber_encoding" title="UBNumber Encoding">

<t>UBNumber is encoding which combines unary and binary encoding to represent values with dynamic length. It is typically representing natural non-negative integer number (or value of any other type with deterministic mapping to well ordered / countably infinite set).</t>

<t>Encoding is similar to UTF-8, except that UBNumber is applied recursively when unary part fills all bits of the first byte.</t>

<t>To decode value, non-zero bits are counted for length up to 8 bits and then rest of bits is used as value. Value is also shifted so that there is only one code for each number.</t>

<t>Examples of the UBNatural - codes sequence of bits = value represented value in basic natural non-negative integer number:

<figure title="UBNumber codes and values">
 <artwork><![CDATA[
  0 0000000                                 = 0
  0 0000001                                 = 1
  0 0000010                                 = 2
  0 0000011                                 = 3
  ...
  0 1111111                                 = 7Fh = 127
  10 000000 | 00000000                      = 80h = 128
  10 000000 | 00000001                      = 81h = 129
  ...
  10 111111 | 11111111                      = 407Fh = 16511
  110 00000 | 00000000 | 00000000           = 4080h = 16512
  ...
]]></artwork>
</figure>
</t>

<t>Various interpretations can be mapped on UBNumber encoding. For level 0 following two mappings are used:

<list style="symbols">
 <t>UBNatural encoding using directly value from UBNumber basic mapping</t>

 <t>UBENatural where value 7Fh is reserved for infinity constant and higher values are shifted by one</t>
</list>
</t>

</section>

<section anchor="document" title="Document">

<t>Single document is typically represented as a single block, but there can be additional optional tail data present.</t>

<t>To store document in the file in file system or for use in the undeclared data stream, additional "Document header" should be present.</t>

<t>Document header contains information about protocol version shall be included. For the version 0.2 of the protocol, it is 6 bytes long data blob. Explanation of the each value is non-conformant, primary use is padding to help systems which uses beginning of file for identification of file type.</t>

<t>Document header with hexadecimal values:</t>

<texttable title="Document Header Bytes">
  <preamble>Structure of file header</preamble>
  
  <ttcol>Byte</ttcol><ttcol>Content</ttcol>

  <c>FE</c><c>Unary encoded size of cluster (byte)</c>
  <c>00</c><c>Reserved for future versions</c>
  <c>58</c><c>ASCII constant 'X'</c>
  <c>42</c><c>ASCII constant 'B'</c>
  <c>00</c><c>UBNatural encoded major version</c>
  <c>02</c><c>UBNatural encoded minor version</c>
</texttable>

<t>Primary block called "Root Block" follows and any data after root block are optional blob called "Tail Data".</t>

</section>

<section anchor="block" title="Block">

<t>There are 3 kinds of blocks: Node Block, Data Block and Terminator</t>

<t>Each block starts with single attribute:

<figure title="">
 <artwork><![CDATA[
  UBNatural attributePartSize
]]></artwork>
</figure>
</t>

<t>If attributePartSize equals 0 then this block is called "Terminator" and block ends.</t>

<t>Otherwise it is followed by blob of the length specified by attributePartSize in bytes. Data in attribute part are interpreted as a nonempty sequence of attributes encoded in UBNumber encoding.</t>

<t>First attribute in attribute part represents value:

<figure title="">
 <artwork><![CDATA[
  UBENatural dataPartSize
]]></artwork>
</figure>
</t>

<t>If dataPartSize value fills exactly whole attribute part then this block is called "Data Block".</t>

<t>Binary blob called data part follows after attribute part and has length in bytes specified by dataPartSize value or if dataPartSize equals infinity, bytes in data part are processed and when byte with value zero is used as escape code and, following byte represents how many bytes of zero it represents or end of the data part if it equals zero as well.</t>

<t>If dataPartSize value fills only part of the attribute part then this block is called "Node Block".</t>

<t>Binary blob called data part follows after attribute part. Data in data part are interpreted as a sequence of (child) blocks.</t>

<t>Data part has length in bytes specified by dataPartSize value or if dataPartSize equals infinity, sequence of blocks must be terminated by terminator block.</t>

<t>After data part block ends.</t>

<t>
<figure title="">
 <artwork><![CDATA[
  +---------------------------------------+
  | == First block's attribute ========== |
  |                                       |
  | UBNatural attributePartSize           |
  +---------------------------------------+
  | == Attribute part (optional) ======== |
  |                                       |
  | UBENatural dataPartSize               |
  | UBNumber attribute 1                  |
  | ...                                   |
  | UBNumber attribute n                  |
  +---------------------------------------+
  | == Data part (optional) ============= |
  |                                       |
  | Single data blob or child blocks      |
  +---------------------------------------+
]]></artwork>
</figure>
</t>
  
<t>See [block examples].</t>

</section>

<section anchor="validity" title="Validity">

<t>Binary stream is structured correctly as XBUP document (well-formed) if the following conditions are met. Description of invalid state is also included for each condition.</t>

<t>
<list style="symbols">
 <t>Optional: Stream header must be present (Corrupted or missing header)</t>

 <t>Optional: Header version must be in supported range (Unsupported version)</t>

 <t>In each block the end of last attribute corresponds to the end of the attribute part (Attribute overflow)</t>

 <t>In each block the end of last subblock corresponds to the end of the data block part (Block overflow)</t>

 <t>The terminal block is present only in blocks where it belongs to (Unexpected terminator)</t>

 <t>End of file is before the end of the root block (Unexpected end of data)</t>
</list>
</t>

</section>

</section>

<section anchor="level_1" title="Level 1: Block Types">

<t>Level 1 introduces block types and catalog of types. Since this level, if attribute is defined, but not present, it's value is considered as zero as in the form of UBNumber encoding.</t>

<section anchor="block_type" title="Block Type">

<t>First two attributes in node block are interpreted as follows (somewhat similar to XML Namespaces):</t>

<t>
<figure title="Block type attributes">
 <artwork><![CDATA[
  UBNatural - TypeGroup
  UBNatural - BlockType
]]></artwork>
</figure>
</t>

<t>These two values determines blocks type.</t>

<t>Block types are organized into groups where TypeGroup value specifies to which group block type belongs and BlockType value specifies particular block type in the corresponding group.</t>

<t>TypeGroup with value 0 is basic build-in group and cannot be overridden. Basic blocks provides ability to specify meaning of other groups via block type declarations, definitions or links to catalog or external source.</t>

</section>

<section anchor="type_context" title="Type Context">

<t>For each block, there is type context which provides mapping of particular block type (as defined above) to particular declaration/definition (similar to XML Namespaces context). Context is the same for block and all it's children, except for "Document Declaration" block which is used to change context.</t>

<t>Range of groups and range of blocks for each group is speficied.</t>

</section>

<section anchor="block_type_definition" title="Block Type Definition">

<t>Block type is defined as a finite sequence of operations where each operation defines one or more attributes and/or child blocks. Operation can define unspecified or refer build-in or previously defined types. There are variants for singular item and list of items, 8 operations in total:

<list style="symbols">
 <t>Single block - Single child block of any type.</t>

 <t>Single attribute - Single attribute of any type.</t>

 <t>Consist of definition - Single child block of referred type (as a component/element).</t>

 <t>Append definition - Appends all attributes and all child blocks of referred type.</t>

 <t>List of any blocks - One attribute of type UBENatural to define count of blocks of any type and child blocks of that count. When count equals infinity, list of blocks ends with empty block.</t>

 <t>List of attributes - One attribute of type UBNatural to define count of attributes of any type and attributes of that count.</t>

 <t>List of consist of definitions - One attribute of type UBENatural to define count of blocks of referred type and child blocks of that count. When count equals infinity, list of blocks ends with empty block.</t>

 <t>List of appended definitions - Appends one attribute of type UBNatural to define count of blocks of defined type and appends all attributes and all child blocks of referred type of that count.</t>
</list>
</t>

<t>Following syntax is used:</t>

<t>
<figure title="Block type attributes">
 <artwork><![CDATA[
  any - Single block
  attribute - Single attribute
  block_type_name - Consist of definition
  +block_type_name - Append definition
]]></artwork>
</figure>
</t>

<t>List variants of the operations ends with brackets "[]".</t>

</section>

<section anchor="basic_blocks_definition" title="Basic Blocks Definition">

<t>Following blocks are defined as build-in. TODO: Move to appendix?</t>

<t>
<list style="symbols">

 <t>Unspecified (0)<vspace/>

 This block is used for unspecified block values or data padding. Can be used to represent nil / null values.</t>

 <t>Document Declaration (1)<vspace/>

 Declaration block determines the allowed range of groups. This block should be located at the beginning of each file, if the application didn't provide any static/special meaning, but it might be used anywhere inside document as well.

<figure title="Document Declaration">
 <artwork><![CDATA[
  +Natural groupsCount - The number of allocated groups
  +Natural preserveGroups - The number of groups to keep from
    previous declarations
  FormatDeclaration formatDeclaration - Declaration of format
  Any documentRoot - Root node of document
]]></artwork>
</figure>

For subblocks of this block there is permitted range of values in the interval group preserveGroups + 1 .. preserveGroups + groupsCount + 1. preservedGroups + groupsCount + 1. If the value reserveGroups = 0, takes the highest not yet reserved group in the current or parental blocks + 1. For all values of zero and the application of rules of cutting the block of zeros coincides with the data block.</t>

 <t>Format Declaration (2)<vspace/>

 Format declaration allows you use either declaration from catalog or local format definition or both.

<figure title="Format Declaration">
 <artwork><![CDATA[
  +CatalogFormatSpecPath catalogFormatSpecPath - Specification
    of format defined as path in catalog
  +Natural formatSpecRevision - Specification's revision number
  FormatDefinition formatDefinition
]]></artwork>
</figure>
</t>

 <t>Format Definition (3)

This block allows to specify the basic structure of format specification. Specifies the sequence of parameters using either join or consist operation.

<figure title="Format Definition">
 <artwork><![CDATA[
  Any[] formatParameters - Join or Consist format parameters
  +RevisionDefinition[] revisions
]]></artwork>
</figure>
 </t>

 <t>Format Join Parameter (4)

<figure title="Format Join Parameter">
 <artwork><![CDATA[
  +FormatDeclaration formatDeclaration
]]></artwork>
</figure>
 </t>

 <t>Format Consist Parameter (5)

<figure title="Format Consist Parameter">
 <artwork><![CDATA[
  +GroupDeclaration groupDeclaration
]]></artwork>
</figure>
 </t>

 <t>Group Declaration (6)

Group declaration allows you use either declaration from catalog or local group definition or both.

<figure title="Group Declaration">
 <artwork><![CDATA[
  +CatalogGroupSpecPath catalogGroupSpecPath - Specification
    of format defined as path in catalog
  +Natural groupSpecRevision - Specification's revision number
  GroupDefinition groupDefinition
]]></artwork>
</figure>
</t>

 <t>Group Definition (7)

This block allows to specify the basic structure of group specification. Specifies the sequence of parameters using either
join or consist operation.

<figure title="Group Definition">
 <artwork><![CDATA[
  Any[] groupParameters - Join or Consist group parameters
  +RevisionDefinition[] revisions
]]></artwork>
</figure>
</t>

 <t>Group Join Parameter (8)

<figure title="Group Join Parameter">
 <artwork><![CDATA[
  +GroupDeclaration groupDeclaration
]]></artwork>
</figure>
</t>

 <t>Group Consist Parameter (9)

<figure title="Group Consist Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>
</t>

 <t>Group Declaration (10)

Block declaration allows you use either declaration from catalog or local block definition or both.

<figure title="Group Declaration">
 <artwork><![CDATA[
  +CatalogBlockSpecPath catalogBlockSpecPath - Specification
    of format defined as path in catalog
  +Natural blockSpecRevision - Specification's revision number
  BlockDefinition blockDefinition
]]></artwork>
</figure>
</t>

 <t>Block Definition (11)

This block allows to specify the basic structure of block specification. Specifies the sequence of parameters using either join, consist, list join or list consist operation.

<figure title="Block Definition">
 <artwork><![CDATA[
  Any[] blockParameters - Join or Consist or List Join or List
    Consist block parameters
  +RevisionDefinition[] revisions
]]></artwork>
</figure>
</t>

 <t>Block Join Parameter (12)

<figure title="Block Join Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>
</t>
  
 <t>Block Consist Parameter (13)

<figure title="Block Consist Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>
</t>

 <t>Block List Join Parameter (14)

<figure title="Block List Join Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>
</t>

 <t>Block List Consist Parameter (15)

<figure title="Block List Consist Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>
</t>

 <t>Revision Definition (16)

Block allows to define parameters count for particular specification definition.

<figure title="Revision Definition">
 <artwork><![CDATA[
  +Natural parametersCount
]]></artwork>
</figure>
</t>

</list>
</t>

</section>

<section anchor="main_catalog" title="Main Catalog">

<t>To specify basic data types, catalog of block type definitions is established.</t>

<t>Catalog is structured as a tree of definitions, where each block type has a unique identifier (sequence of natural numbers).</t>

</section>

</section>

<section anchor="level_2" title="Level 2: Transformations">


</section>

</section>

<section anchor="todo" title="Todo">

<section anchor="examples_of_blocks" title="Examples of Blocks">

<t>Fixed size node block with one attribute</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>02</c><c>AttributePartSize</c>
  <c>00</c><c>DataPartSize</c>
  <c>77</c><c>Attribute 1 of value 0x77</c>
</texttable>

<t>Terminated node block with one attribute</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>02</c><c>AttributePartSize</c>
  <c>7F</c><c>DataPartSize</c>
  <c>05</c><c>Attribute 1</c>
  <c>00</c><c>Terminator</c>
</texttable>

<t>Fixed size data block</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>01</c><c>AttributePartSize</c>
  <c>01</c><c>DataPartSize</c>
  <c>BB</c><c>One byte of data 0xBB</c>
</texttable>

<t>Terminated empty data block</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>01</c><c>AttributePartSize</c>
  <c>7F</c><c>DataPartSize</c>
  <c>00</c><c>Data block escape</c>
  <c>00</c><c>Termination value</c>
</texttable>

<t>Fixed block with one child</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>02</c><c>AttributePartSize</c>
  <c>03</c><c>DataPartSize</c>
  <c>66</c><c>Attribute 1 of value 0x66</c>
  <c>  02</c><c>AttributePartSize</c>
  <c>  00</c><c>DataPartSize</c>
  <c>  77</c><c>Attribute 1 of value 0x77</c>
</texttable>

</section>

<section anchor="appendix_abstraction" title="Appendix 1: Abstraction">

<t>Concept of data used in this protocol is using set theory, where set must be countable as well for each member of data there must exist mapping to countable set.</t>

<t>At the same time data definitions are similar to table columns definition used in relation databases, except that infinite number of items is also supported.</t>

<t>Protocol processing is based on broad concept of dataflow paradigm, which typically state that there are input data, process and output data.</t>

<t>Additional requirement here is, that process must be deterministic (for same input return the same output), but other than that, it can be run in any manner - from local function in memory up to remote process in cloud.</t>

</section>

<section anchor="appendix_parsing" title="Appendix 2: Parsing">

<t>Similar to parsing of textual formats, it's possible to provide parsing capability for binary protocol.

<list style="symbols">
<t>Object Model Parsing</t>
<t>Pull Parsing</t>
<t>Event Parsing</t>
<t>Hybrid Approaches</t>
</list>

</t>

<section anchor="appendix_parsing_level_0" title="Level 0 Parsing">

<t>To process level 0 protocol following 4 types of tokens are used:

<list style="symbols">

 <t>begin (terminationMode flag)</t>
 <t>attribute (UBNumber value)</t>
 <t>data (Binary data)</t>
 <t>end</t>

</list>
</t>

<t>Following simplified grammar can be used for token processing.</t>

<t>
<figure title="Simplified grammar">
 <artwork><![CDATA[
  Document ::= header + Block + data
  Block ::= begin + Attributes + Blocks + end | begin + data + end
  Blocks ::= Block + Blocks | epsilon
  Attributes ::= attribute + Attributes | epsilon
]]></artwork>
</figure>
</t>

</section>

</section>

</section>

<section anchor="IANA" title="IANA Considerations">

<t>In the current early state of the development of the protocol, just basic media type for general files is defined: application/x-xbup</t>

</section>

<section anchor="Security" title="Security Considerations">

<t>TBD</t>

</section>

<section anchor="Acknowledgements" title="Acknowledgements">

<t>TBD</t>

<iref item="Introduction" subitem="verbiage" primary="true"/>

</section>

</middle>

<back>

<references title="Normative References">

&RFC2119;

</references>

</back>
</rfc>