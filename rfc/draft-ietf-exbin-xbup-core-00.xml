<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3117 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3117.xml">
<!ENTITY RFC3629 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3629.xml">
<!ENTITY RFC4627 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY RFC7049 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7049.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc strict="yes" ?>

<rfc
  category="exp"
  docName="draft-ietf-exbin-xbup-core-00"
  ipr="trust200902"
  submissionType="independent"
  xml:lang="en"
>

<front>
<title abbrev="XBUP">
Extensible Binary Universal Protocol (XBUP)
</title>

<author fullname="Miroslav Hajda" surname="Hajda" initials="M.">
<organization>ExBin Project</organization>
<address>
<email>exbinproject@gmail.com</email>
<uri>https://exbin.org/</uri>
</address>
</author>

<!--<date year="2020" month="September"/>-->

<area>General</area>
<workgroup>(NONE)</workgroup>
<keyword>Binary</keyword>
<keyword>Protocol</keyword>

<abstract>
<t>The Extensible Binary Universal Protocol (XBUP) is general purpose binary data protocol and file format with primary focus on data abstraction and data transformation.</t>
<t>This proposal describes specification of the currently developed prototype version, example set of basic data types and the recommended API.</t>
<t>Protocol is part of the <eref target="https://exbin.org">ExBin Project</eref>, which aims to provide proof-of-concept implementation and support for wider set of functionality.</t>
<t>NOTICE: This is not official or finished document and is not yet enrolled for any official track to be registered as IETF RFC.</t>
</abstract>

<note title="Contributing">
<t>This document is being worked on by <eref target="https://exbin.org">ExBin Project</eref>, published here in order to gather comments and to raise interest in this project.</t>
<t>To participate on the development of this project, visit <eref target="https://xbup.exbin.org/?participate">https://xbup.exbin.org/?participate</eref>.</t>
</note>

</front>

<middle>

<section anchor="intro" title="Introduction">

<t>The Extensible Binary Universal Protocol (XBUP) is a prototype of general purpose multi-layer binary data protocol and file format with primary focus on abstraction and data transformation.</t>

<t>Key features:
<list style="symbols">
 <t>Unified block-tree structure - Minimalist tree structure based on integer and binary blob only</t>
 <t>Custom data types - Support for data type definitions and catalogs of types</t>
 <t>Transformation framework - Automatic and manual data conversions and compatibility handling</t>
</list>
</t>

<t>Secondary features includes some capabilities inspired by markup languages like SGML/XML <xref target="XML"/> and data representation languages like YAML <xref target="YAML"/>, JSON <xref target="RFC4627"/> and similar binary formats like ASN.1 <xref target="ASN.1"/>, HDF5 <xref target="HDF5"/>, efficient XML <xref target="EfficientXML"/> or Protocol Buffers <xref target="ProtoBuf"/>.
<list style="symbols">
 <t>Extensibility</t>
 <t>Unconstrained values</t>
 <t>Internal and external referencing</t>
 <t>Data life-cycle / definition evolution</t>
</list>
</t>

<section anchor="goals" title="Goals">

<t>The primary goal of this project is to create a communication protocol / data format with the following characteristics, order by priority:

<list style="symbols">
 <t>Universal - Capable of representation of any type of data, suitable for wide range of use including streaming, long-term storage and parallel accessing</t>
 <t>Independent - Not tightly linked to a particular spoken language, product, company, processing architecture or programming language</t>
 <t>Declarative - Self sufficient for data type definition and with the ability to build data types by combining existing ones</t>
 <t>Normative - Providing reference form for data representation</t>
 <t>Flexible - Support for data transformations, compatibility and extensibility handling</t>
 <t>Efficient - Effective data compacting / compression support for plain binary and structured data</t>
</list>
</t>

</section>

<section anchor="terminology" title="Terminology">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
in this document are to be interpreted as described in
<xref target="RFC2119"/>.</t>

<t>The term "byte" is used in its now-customary sense as a synonym for "octet" - sequence of 8 bits.</t>
   
</section>
</section>

<section anchor="specification" title="XBUP Specification">

<t>XBUP is multi-layer protocol for representation of data in bit/byte stream provided by other protocols / file data etc. Each layer is build on top of previous layer providing new capabilities, like new constraints and/or features. Higher levels can also declare retrospectivelly entities used in lower levels.</t>

<t>Applications can choose to support only up to specific layer of XBUP protocol when full support is not necessary.</t>

<t>Layers are indexed as levels by depth starting with level 0.</t>

<texttable title="Layers">
  <preamble>Layers of the protocol</preamble>
  <ttcol>Level</ttcol><ttcol>Layer</ttcol>

  <c>0</c><c>Tree Structure</c>

  <c>1</c><c>Type System</c>

  <c>2</c><c>Transformations</c>

  <c>3</c><c>Relations</c>
</texttable>

<section anchor="level_0" title="Level 0: Tree Structure">

<t>Lowest protocol's level defines basic tree structure using two primitive types.</t>

<t>
<list style="symbols">
 <t>UBNumber encoded value</t>
 <t>Blob - Sequence of bits (bytes) with unspecified length or length specified by some attribute</t>
</list>
</t>

<t>Sequence of those primitive types forms a block. Single block represents node of the tree and can contain child blocks which are representing child nodes.</t>

<section anchor="ubnumber_encoding" title="UBNumber Encoding">

<t>UBNumber is encoding which combines unary and binary encoding with varying length of units of bits (octets). It is typically representing natural non-negative integer number (or value of any other type with deterministic mapping to well ordered / countably infinite set). Encoding is applied recursively when unary part fills all bits of the first byte.</t>

<t>This is similar to other varying length encoding, for example used in <xref target="RFC3629">UTF-8</xref>.</t>

<t>To decode value, non-zero bits are counted for length up to 8 bits and then rest of bits is used as value + additional sequence of n bytes where n equals to length. Value is also shifted so that there is only one code for each number. For bit value 0xFF which corresponds to length 8, additional UBNatural value is added next. This new value contains additional length value.</t>

<t>Examples of the UBNatural - codes sequence of bits = value represented value in basic natural non-negative integer number:</t>

<figure title="UBNatural example codes and values">
 <artwork><![CDATA[
  0 0000000                                 = 0
  0 0000001                                 = 1
  0 0000010                                 = 2
  0 0000011                                 = 3
  ...
  0 1111111                                 = 7Fh = 127
  10 000000 | 00000000                      = 80h = 128
  10 000000 | 00000001                      = 81h = 129
  ...
  10 111111 | 11111111                      = 407Fh = 16511
  110 00000 | 00000000 | 00000000           = 4080h = 16512
  ...
  11111110 11111111 .. 11111111             = 10204081020407Fh
           \_____ 7 times ____/
  ...
  11111111 00000000 00000000 .. 00000000    = 102040810204080h
           \+len 0/ \_____ 8 times ____/
  ...
  11111111 00000001 00000000 .. 00000000    = 10102040810204080h
           \+len 1/ \_____ 9 times ____/
]]></artwork>
</figure>

<t>Other mappings to represent different values than natural numbers can be also used with UBNumber encoding. For level 0 following two mappings are used:

<list style="symbols">
 <t>UBNatural encoding using directly value from UBNumber basic mapping as listed above</t>
 <t>UBENatural where value 7Fh is reserved for infinity constant and higher codes are shifted by one</t>
</list>
</t>

</section>

<section anchor="document" title="Document">

<t>Single document is typically represented as a single block, but data after this block are also considered part of the document.</t>

<t>To store document in the file / file system or in data streams protocol version was not negotiated prior, additional "Document header" should be present.</t>

<t>Document header contains information about protocol version. For the current version 0.2 of the protocol, it is 6 bytes long data blob. Explanation of each value is non-conformant, primary use is padding to help systems which uses beginning of file for identification of file type.</t>

<t>Document header with hexadecimal values:</t>

<texttable title="Document Header Bytes">
  <preamble>Structure of file header</preamble>
  
  <ttcol>Byte</ttcol><ttcol>Content</ttcol>

  <c>FE</c><c>Unary encoded size of cluster (byte)</c>
  <c>00</c><c>Reserved for future versions</c>
  <c>58</c><c>ASCII constant 'X'</c>
  <c>42</c><c>ASCII constant 'B'</c>
  <c>00</c><c>UBNatural encoded major version</c>
  <c>02</c><c>UBNatural encoded minor version</c>
</texttable>

<t>Primary block called "Root Block" follows after header. Any data after root block are optional data blob called "Tail Data".</t>

</section>

<section anchor="block" title="Block">

<t>Block specifies encoding / decoding method for bytes sequence into sequence of blobs or child blocks and to defere its own size.</t>

<t>Each block starts with the value:</t>

<figure title="">
 <artwork><![CDATA[
  UBNatural attributePartSize
]]></artwork>
</figure>

<t>Value attributePartSize is not allowed to equal to 0 for the block as value 0 is used for termination handling (see below).</t>

<t>Block continues with attribute part which is blob of the length in bytes specified by attributePartSize.</t>

<t>First value in attribute part represents:</t>

<figure title="">
 <artwork><![CDATA[
  UBENatural dataPartSize
]]></artwork>
</figure>

<t>Rest of the data (if any) in the attribute part is interpreted as a nonempty sequence of attribute values encoded in any UBNumber encoding. Binary blob called data part follows after attribute part - is optional / can be empty.</t>

<t>If the dataPartSize value fills exactly whole space of the attribute part (there are no more attributes in attribute part) then this block is called "Data Block" otherwise block is called "Node Block".</t>

<t>After data part section, block ends.</t>

<figure title="">
 <artwork><![CDATA[
  +-------------------------------------+
  | == Block ========================== |
  |                                     |
  | UBNatural attributePartSize         |
  +-------------------------------------+
  | == Attribute part ================= |
  |                                     |
  | UBENatural dataPartSize             |
  | UBNumber attribute 1                |
  | ...                                 |
  | UBNumber attribute n                |
  +-------------------------------------+
  | == Data part (optional) =========== |
  |                                     |
  | Single data blob or child blocks    |
  +-------------------------------------+
]]></artwork>
</figure>

<t>Effectively, transferred data are represented as a sequence of attributes and child blocks or data blob, while attributePartSize and dataPartSize values are present for the structural purpose.</t>

<t>See <xref target="appendix_examples_of_blocks">examples of blocks</xref>.</t>

</section>

<section anchor="node_block" title="Node Block">

<t>When there is at least one attribute value in attribute part, block is called node block. Data in data part are interpreted as a sequence of (child) blocks.</t>

<t>Data part has length in bytes specified by dataPartSize value or if dataPartSize equals infinity, sequence of child blocks can be infinite or terminated by terminator (single zero byte value).</t>

<t>If there are no child blocks, node block is also called leaf block.</t>

</section>

<section anchor="data_block" title="Data Block">

<t>When there is no attribute value in attribute part, block is called data block. Data in data part are interpreted as a binary blob.</t>

<t>Data part has length in bytes specified by dataPartSize value or if dataPartSize equals infinity, data part is processed by byte and each value zero is used as a escape code, where directly following byte means:

<list style="symbols">
 <t>Value 0 denotes end of the data part</t>
 <t>Value 1 to 255 denotes sequence of zero bytes of given count and processing continues</t>
</list>
</t>

<t>If there is no data in data part, data block is also called empty block.</t>

</section>

<section anchor="validity" title="Validity">

<t>Binary stream is structured correctly as XBUP document (well-formed) if the following conditions are met. Description of invalid state is also included for each condition.</t>

<t>
<list style="symbols">
 <t>Optional: Stream header must be present (Corrupted or missing header)</t>

 <t>Optional: Header version must be in supported range (Unsupported version)</t>

 <t>In each block the end of last attribute corresponds to the end of the attribute part (Attribute overflow)</t>

 <t>In each block the end of last subblock/child block corresponds to the end of the data part (Block overflow)</t>

 <t>The terminal block is present only in blocks where it belongs to (Unexpected terminator)</t>

 <t>End of file / data stream is before the end of the root block (Unexpected end of data)</t>
</list>
</t>

</section>

<section anchor="level_0_summary" title="Summary">

<t>To sum it up, data in protocol are structured as a tree of blocks.</t>

<t>
<list style="symbols">
 <t>Block is either data blob or finite sequence of attributes and child blocks</t>

 <t>Block can have specified size - this allows to skip block processing, but also requires to know size of the block in advance when encoding</t>
 
 <t>For block with unknown size, it's possible to use infinity size + termination or sequence of child blocks cound never end</t>

 <t>Data block has no attributes, so either have to be wrapped or meaning should be understandable from the content / context</t>

 </list>
</t>

<t>In theory, this should provide sufficient capability to represent any data when encoding to blob is available. More complex types can be either constructed using deeper tree structure or compacted into binary blob, but it should be possible to derive data type via transformation to basic data elements when needed.</t> 

</section>

</section>

<section anchor="level_1" title="Level 1: Block Types">

<t>Level 1 introduces block types, how to specify type of the block and catalog of types. Approach is somewhat similar to <xref target="XMLNamespaces">XML Namespaces</xref>.</t>

<t>Since this level, if attribute is defined, but not present, it's value is considered as zero code of the UBNumber encoding.</t>

<section anchor="block_type" title="Block Type">

<t>First two attributes in node block are interpreted as follows:</t>

<figure title="Block type attributes">
 <artwork><![CDATA[
  UBNatural - TypeGroup
  UBNatural - BlockType
]]></artwork>
</figure>

<t>These two values determine block type. Block types are organized into groups where TypeGroup value specifies to which group block type belongs and BlockType value specifies particular block type in the corresponding group.</t>

<t>TypeGroup with value 0 is always basic build-in group (cannot be overridden). Basic blocks provides ability to specify meaning of other groups via block type declarations, definitions or links to catalog or external source.</t>

</section>

<section anchor="type_context" title="Type Context">

<t>For each block, there is type context which provides mapping of particular block type (as defined above) to particular declaration/definition (similar to XML Namespaces context). Context is the same for block and all it's children, except for "Document Declaration" block which is used to change context.</t>

<t>Range of groups and range of blocks for each group is speficied.</t>

</section>

<section anchor="block_type_definition" title="Block Type Definition">

<t>Block type is defined as a finite sequence of operations where each operation defines one or more attributes and/or child blocks. Operation can refer build-in or previously defined types or no type (for attribute and any). There are variants for singular item and list of items, 8 operations in total:

<list style="symbols">
 <t>Single block - Single child block of any type.</t>

 <t>Single attribute - Single attribute of any type.</t>

 <t>Consist of definition - Single child block of referred type (as a component/element).</t>

 <t>Append definition - Appends all attributes and all child blocks of referred type.</t>

 <t>List of blocks - One attribute of type UBENatural to define count of blocks of any type and child blocks of that count. When count equals infinity, list of blocks ends with empty block.</t>

 <t>List of attributes - One attribute of type UBNatural to define count of attributes of any type and attributes of that count.</t>

 <t>List of consist of definitions - One attribute of type UBENatural to define count of blocks of referred type and child blocks of that count. When count equals infinity, list of blocks ends with empty block.</t>

 <t>List of appended definitions - Appends one attribute of type UBNatural to define count of blocks of defined type and appends all attributes and all child blocks of referred type of that count.</t>
</list>
</t>

<t>Following syntax is used in this document (no final syntax is decided yet):</t>

<figure title="Block type attributes">
 <artwork><![CDATA[
  any - Single block
  attribute - Single attribute
  Block_type_name - Consist of definition
  +Block_type_name - Append definition

  []any - List of blocks
  []attribute - List of attributes
  []Block_type_name - List of consist of definition
  +[]Block_type_name - List of append definition
]]></artwork>
</figure>

<t>From the abstract point of view (more about <xref target="appendix_abstraction">abstraction</xref>) type definition is simply ordered list of child singular types or sets of child types including infinite number of them.</t>  

<t>At the same time data definitions are similar to the table columns definition used in relation databases, except that infinite number of items is also supported.</t>

</section>

<section anchor="basics" title="Basic Blocks Definition">

<t>Following blocks are defined as build-in group 0, but also defined in catalog.</t>

<section anchor="basic_unspecified" title="Unspecified (0)">

<t>This block is used for unspecified block values or data padding. Can be used to represent nil / null values.</t>

</section>

<section anchor="basic_document_declaration" title="Document Declaration (1)">

<t>Declaration block determines the allowed range of groups. This block should be located at the beginning of each file, if the application didn't provide any static/special meaning, but it might be used anywhere inside document as well.</t>

<figure title="Document Declaration">
 <artwork><![CDATA[
  +Natural groupsCount - The number of allocated groups
  +Natural preserveGroups - The number of groups to keep from
    previous declarations
  FormatDeclaration formatDeclaration - Declaration of format
  Any documentRoot - Root node of document
]]></artwork>
</figure>

<t>For subblocks of this block there is permitted range of values in the interval group preserveGroups + 1 .. preserveGroups + groupsCount + 1. preservedGroups + groupsCount + 1. If the value reserveGroups = 0, takes the highest not yet reserved group in the current or parental blocks + 1. For all values of zero and the application of rules of cutting the block of zeros coincides with the data block.</t>

</section>

<section anchor="basic_format_declaration" title="Format Declaration (2)">

<t>Format declaration allows you use either declaration from catalog or local format definition or both.</t>

<figure title="Format Declaration">
 <artwork><![CDATA[
  +CatalogFormatSpecPath catalogFormatSpecPath - Specification
    of format defined as path in catalog
  +Natural formatSpecRevision - Specification's revision number
  FormatDefinition formatDefinition
]]></artwork>
</figure>

</section>

<section anchor="basic_format_definition" title="Format Definition (3)">

<t>This block allows to specify the basic structure of format specification. Specifies the sequence of parameters using either join or consist operation.</t>

<figure title="Format Definition">
 <artwork><![CDATA[
  Any[] formatParameters - Join or Consist format parameters
  +RevisionDefinition[] revisions
]]></artwork>
</figure>

</section>

<section anchor="basic_format_join_parameter" title="Format Join Parameter (4)">

<t>Join parameter for format definition.</t>

<figure title="Format Join Parameter">
 <artwork><![CDATA[
  +FormatDeclaration formatDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_format_consist_parameter" title="Format Consist Parameter (5)">

<t>Consist parameter for format definition.</t>

<figure title="Format Consist Parameter">
 <artwork><![CDATA[
  +GroupDeclaration groupDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_group_declaration" title="Group Declaration (6)">

<t>Group declaration allows you use either declaration from catalog or local group definition or both.</t>

<figure title="Group Declaration">
 <artwork><![CDATA[
  +CatalogGroupSpecPath catalogGroupSpecPath - Specification
    of format defined as path in catalog
  +Natural groupSpecRevision - Specification's revision number
  GroupDefinition groupDefinition
]]></artwork>
</figure>

</section>

<section anchor="basic_group_definition" title="Group Definition (7)">

<t>This block allows to specify the basic structure of group specification. Specifies the sequence of parameters using either
join or consist operation.</t>

<figure title="Group Definition">
 <artwork><![CDATA[
  Any[] groupParameters - Join or Consist group parameters
  +RevisionDefinition[] revisions
]]></artwork>
</figure>

</section>

<section anchor="basic_group_join_parameter" title="Group Join Parameter (8)">

<t>Join parameter for group definition.</t>

<figure title="Group Join Parameter">
 <artwork><![CDATA[
  +GroupDeclaration groupDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_group_consist_parameter" title="Group Consist Parameter (9)">

<t>Consist parameter for group definition.</t>

<figure title="Group Consist Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_block_declaration" title="Block Declaration (10)">

<t>Block declaration allows you use either declaration from catalog or local block definition or both.</t>

<figure title="Block Declaration">
 <artwork><![CDATA[
  +CatalogBlockSpecPath catalogBlockSpecPath - Specification
    of format defined as path in catalog
  +Natural blockSpecRevision - Specification's revision number
  BlockDefinition blockDefinition
]]></artwork>
</figure>

</section>

<section anchor="basic_block_definition" title="Block Definition (11)">

<t>This block allows to specify the basic structure of block specification. Specifies the sequence of parameters using either join, consist, list join or list consist operation.</t>

<figure title="Block Definition">
 <artwork><![CDATA[
  Any[] blockParameters - Join or Consist or List Join or List
    Consist block parameters
  +RevisionDefinition[] revisions
]]></artwork>
</figure>

</section>

<section anchor="basic_block_join_parameter" title="Block Join Parameter (12)">

<t>Join parameter for block definition.</t>

<figure title="Block Join Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_block_consist_parameter" title="Block Consist Parameter (13)">
  
<t>Consist parameter for block definition.</t>

<figure title="Block Consist Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_block_list_join_parameter" title="Block List Join Parameter (14)">

<t>List join parameter for block definition.</t>

<figure title="Block List Join Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_block_list_consist_parameter" title="Block List Consist Parameter (15)">

<t>List consist parameter for block definition.</t>

<figure title="Block List Consist Parameter">
 <artwork><![CDATA[
  +BlockDeclaration blockDeclaration
]]></artwork>
</figure>

</section>

<section anchor="basic_revision_definition" title="Revision Definition (16)">

<t>Revision allows to define parameters count for particular specification definition.</t>

<figure title="Revision Definition">
 <artwork><![CDATA[
  +Natural parametersCount
]]></artwork>
</figure>

</section>

</section>

<section anchor="main_catalog" title="Main Catalog">

<t>To specify basic data types, catalog of block type definitions is established.</t>

<t>Catalog is structured as a tree of definitions, where each block type has a unique identifier (sequence of natural numbers). Tree nodes are denoted by ownership base and are suppose to follow similar pattern like internet domain names.</t>

<t>Additional to block, group and format specifications, catalog can contain basically any other data which will be properly specified on further protocol levels, for example:

<list style="symbols">

<t>Name of the type in multiple languages</t>
<t>Documentation for given type</t>
<t>Icon</t>
<t>Author / ownership</t>
<t>Custom viewer/editor</t>

</list>
</t>

<t>For basic access, catalog should be accesible as single document stored in XBUP format.</t>

</section>

<section anchor="additional_catalogs" title="Additional Catalogs">

<t>Additional catalogs can be addressed from external sources.</t>

</section>

</section>

<section anchor="level_2" title="Level 2: Transformations">

<t>In general, block transformation is data flow from one block type to another block type (more about <xref target="appendix_abstraction">abstraction</xref>). Transformation can be used for multiple tasks and cover various operations with data.</t>

<t>This level introduces capability to define transformations in catalog and automatically performs conversion between blocks.</t>

<t>Protocol processing is based on broad concept of dataflow paradigm, which typically state that there are input data, operation and output data.</t>

<t>Additional requirement here is, that operation must be deterministic (for same input returns the same output), but other than that, it can be run in any manner - as a local function in memory up to remote process in cloud.</t>

<t>Transformations can be also used for:

<list style="symbols">

<t>Paging</t>
<t>Compression</t>
<t>Encryption</t>
<t>Specify operation between multiple blocks</t>
<t>TODO</t>

</list>
</t>

<t>Additional properties can be specified for the transformation, like for example:

<list style="symbols">

<t>Time complexity</t>
<t>Space complexity</t>
<t>...</t>

</list>
</t>

<t>TODO</t>

<section anchor="automatic_conversion" title="Automatic Conversion">
<t>Support for transformations is used for automatic conversion of data when applications accesses this data with tools supporting this level of the protocol.</t>

<t>Typically application requests data to be send in a specific format, which it can process from a system service or a providing library and data are converted to the requested form.</t>

<t>Depending on the accessing method, transformations can be provided omni- or bi-direction. Processing service can also handle additional requirements for combination of various conversions.</t>

<t>General policy is to allow to include any type of data along side the main required type even when data are in transformed state, therefore it's still possible to include data outside the current specialized form for universal storage.</t>

</section>

<section anchor="paging" title="Paging">

<t>Support for basic data paging is available in basic catalog. Paging is solved using single data blob which is split into pages of the same size. Either each block of the full block structure can be stored in a way, that each block starts in new page or specific behavior can be defined via algorithm.</t>

</section>

</section>

<section anchor="level_3" title="Level 3: Ontologies">

<t>Following level can additionaly specify more about meaning of the data:

<list style="symbols">

<t>Restrict number of items in list</t>
<t>Restrict type of any type</t>
<t>Specify restricted document structure</t>
<t>Restrict allowed transformations</t>
<t>Specify relations between blocks</t>

</list>
</t>

<t>This level introduces entities and relations to the catalog.</t>

</section>

<section anchor="data_types" title="Data Types">

<t>Following section defines various data types considered for specification in catalog.</t>

<t>Typically, where exists automatic transformation between types in each group, either full or with some exceptions.</t>

<section anchor="type_group_boolean" title="Boolean">

<t>For boolean logical value typical entities for "True" and "False" are declared.</t>
<t>Boolean can be also stored as attribute 0/1 or 0/1 in blob value.</t>

<t>TODO</t>

<section anchor="type_ubboolean" title="UBBoolean">

<t>Basic variant using single attribute to store 0 or 1 for false/true.</t>

<figure title="UBBoolean Definition">
 <artwork><![CDATA[
  +Natural value
]]></artwork>
</figure>

</section>

<section anchor="type_databoolean" title="DataBoolean">

<t>Variant using data blob to store single byte 0 or 1 for false/true. When compacting, single bit could be actually used.</t>

<figure title="DataBoolean Definition">
 <artwork><![CDATA[
  Blob value
]]></artwork>
</figure>

</section>

</section>

<section anchor="type_group_natural" title="Natural Number">

<t>Natural numbers represent non-negative integer values, also called unsigned integer.</t>
<t>Natural type is also used as primary mapping for UBNumber encoding.</t>
<t>Value can be stored as single attribute or blob value.</t>
<t>Alternativelly value can be limited to specific maximum or blob length, typically specified in bits, for example natural value in 16, 32, 24, 64 bits, possibly even with swapped parts (endian etc.).</t>

<t>TODO</t>

</section>

<section anchor="type_group_integer" title="Integer Number">

<t>Integer value extends range to all integer values including negative values.</t>
<t>Integer can be stored using UBNumber encoding using 2-complement form.</t>
<t>Value can be stored as single attribute or blob value.</t>
<t>Alternativelly value can be limited to specific minimum and maximum or blob length, typically specified in bits, for example integer value in 16, 32, 24, 64 bits, possibly even with swapped parts (endian etc.).</t>

<t>TODO</t>

</section>

<section anchor="type_group_real" title="Real Number">

<t>Real numbers have fractional part. Also called float or double.</t>
<t>Basic supported form is to use two integer attributes, one to represent base and other for mantisa. This will allow to store any real number of finite precision.</t>
<t>Alternative type is using <xref target="IEEE.754.1985"/> stored in blob.</t>

<t>TODO</t>

<section anchor="type_ubreal" title="UBReal">

<t>Basic variant using two UBInteger attributes to represent any real number with finite binary fraction.</t>

<figure title="UBReal Definition">
 <artwork><![CDATA[
  +UBInteger base
  +UBInteger mantissa
]]></artwork>
</figure>

<t>To eliminate redundancy, method of adding invisible bit before decimal point is used - with extra decrement for zero value.</t>

<figure title="UBReal algorithm">
 <artwork><![CDATA[
  if (Base = 0 and Mantissa = 0) the Value := 0 else {
    Value := (Base * 2 + 1) * (2 ^ Mantissa)
    if (Base > 0 and Mantissa = 0) then Value := Value - 2
  }
]]></artwork>
</figure>

<figure title="UBReal example codes and values">
<artwork><![CDATA[
  ...
  (10)111111 11111111  (0)0000000          = -81h
  (0)1000000  (0)0000000                   = -7Fh
  (0)1000001  (0)0000000                   = -7Dh
  ...
  (0)1111110  (0)0000000                   = -3
  (0)1111111  (0)0000000                   = -1
  (0)0000000  (0)0000000                   = 0 (1)
  (0)0000001  (0)0000000                   = 1 (3)
  (0)0000010  (0)0000000                   = 3 (5)
  ...
  (0)0111111  (0)0000000                   = 7Dh (7Fh)
  (10)000000 00000000  (0)0000000          = 7Fh (81h)
  ...
]]></artwork>
</figure>

<t>Examples with non-zero mantissa:</t>

<figure title="UBReal example codes and values">
<artwork><![CDATA[
  (0)1111111  (0)0000001                   = -2
  (0)0000000  (0)0000001                   = 2
  (0)0000001  (0)0000001                   = 6
  (0)0000010  (0)0000001                   = 10
  (0)0000000  (0)0000010                   = 4
  (0)0000000  (0)0000011                   = 8
  (0)0000000  (0)1111111                   = 0.5
  (0)0000001  (0)1111111                   = 1.5
]]></artwork>
</figure>

</section>

<section anchor="type_datareal" title="DataReal">

<t>Variant using data blob to store real numbers.</t>

<figure title="DataReal Definition">
 <artwork><![CDATA[
  Blob value
]]></artwork>
</figure>

</section>

<section anchor="type_ubratio" title="UBRatio">

<t>Variant of real number with fixed range using single UBNatural attribute to represent any real number with finite binary fraction in range &lt;0, 1&gt;.</t>

<figure title="UBRatio Definition">
 <artwork><![CDATA[
  +UBNatural value
]]></artwork>
</figure>

<t>Method of reverting value is used.</t>

<figure title="UBRatio algorithm">
 <artwork><![CDATA[
  Value := Input
  if not (Value=0 or Value=1) then (
    Value := Value + 1
    while (Value = Trunc(Value)) do ( Value := Value * 2)
    Value := Trunc(Value/2) + 1
  )
]]></artwork>
</figure>

<figure title="UBRatio example codes and values">
<artwork><![CDATA[
  (0)0000000  0                          = 0     = 0
  (0)0000001  1                          = 1     = 1
  (0)0000010  0.1                        = 1/2   = 0.5
  (0)0000011  0.01                       = 1/4   = 0.25
  (0)0000100  0.11                       = 3/4   = 0.75
  (0)0000101  0.001                      = 1/8   = 0.125
  (0)0000110  0.011                      = 3/8   = 0.375
  (0)0000111  0.101                      = 5/8   = 0.625
  (0)0001000  0.111                      = 7/8   = 0,875
  (0)0001001  0.0001                     = 1/16  = 0,0625
  (0)0001010  0.0011                     = 3/16  = 0,1875
  (0)0001011  0.0101                     = 5/16  = 0,3125
  ...
]]></artwork>
</figure>

</section>

<section anchor="type_ubfixedpoint" title="UBFixedPoint">

<t>Variant of real number with fixed precision is simply stored as UBInteger and using specific scaling. There can be also non-negative variant using UBNatural attribute.</t>

<figure title="UBFixedPoint Definition">
 <artwork><![CDATA[
  +UBInteger value
]]></artwork>
</figure>

<t>Values are simply multiplied by scale, for example for ratio 1/100.</t>

<figure title="UBFixedPoint algorithm">
 <artwork><![CDATA[
  Value := Input * 0.01
]]></artwork>
</figure>

<figure title="UBFixedPoint example codes and values">
<artwork><![CDATA[
  (0)0000000                             = 0
  (0)0000001                             = 0.01
  (0)0000010                             = 0.02
  ...
]]></artwork>
</figure>

</section>

</section>

<section anchor="type_group_string" title="String">

<t>Text string can be represented using various encodings.</t>
<t>Basic string type is using UTF-8 encoding by default.</t>
<t>Alternative type allows to specify used encoding using either IANA MIME name or encoding MIB index.</t>

<t>TODO</t>

<section anchor="type_string" title="String">

<t>Basic UTF-8 encoded string stored as binary blob.</t>

<figure title="String Definition">
 <artwork><![CDATA[
  Blob value
]]></artwork>
</figure>

</section>

<section anchor="type_utf16string" title="Utf16String">

<t>Basic UTF-16 encoded string stored as binary blob.</t>

<figure title="UTF16String Definition">
 <artwork><![CDATA[
  Blob value
]]></artwork>
</figure>

</section>

</section>

<section anchor="type_group_time" title="Time">

<t>Various types are defined to specify concrete date, time, timezone...</t>
<t>Types for time interval / range</t>

<t>TODO</t>

</section>

<section anchor="type_group_url" title="URL - Uniform Resource Locator">

<t>Basic URL type is using string representation of the URL.</t>

<t>URL can be used to specify additional external catalogs.</t>

<t>TODO</t>

</section>

<section anchor="type_group_coordinates" title="Coordinates">

<t>Types to represent coordinates, like position on planet via latitude, longitude, altitude, elevation, rotation, GPS coordinates, distance.</t>

</section>

</section>

<section anchor="algorithms" title="Algorithms">

<t>Algorithms in the protocol are based on data-flow concept similar to what is used for transformations. This allows to define algorithms in wide range of paradigms including functional, logical and imperative.</t>

<t></t>

</section>

</section>

<section anchor="appendixes" title="Appendixes">

<section anchor="appendix_motivation" title="Appendix: Motivation">

<t>Project should provide universal protocol as a more feature-rich alternative to currently used binary protocols. It should provide general methods for handling data of various form and types including:

<list style="symbols">
 <t>Multimedia files - Audio, video, animation, 3D</t>
 <t>Serialization protocol - Provide ability to serialize non-structured data</t>
 <t>Application API - Remote or local method call execution, supporting parameters and result passing and error handling</t>
 <t>Filesystem structure - Allow to represent data in the form of filesystem or as a compressed archive</t>
 <t>Huge data - Use dynamic numeric values to allow support for data in terabytes range or greater</t>
 <t>Random access - Segmented, paged, fragmented data</t>
 <t>Parallel processing - Atomicity, structural data for database representation</t>
 <t>Indexes, error detection and data correction</t>
</list>
</t>

<t>From the users point of view, protocol should provide new capabilities or enable new development in various areas:

<list style="symbols">
 <t>Browseable binary content - Provide capability for viewing and editation of data, including visual and graphical tools and textual tools with multiple available syntaxes and supported languages</t>
 <t>Flexible modular applications - With the ability to provide both independent API and data interchange format and with automatic transformation between both of them, it should be possible to utilize the protocol to enhance approach for modular applications design</t>
 <t>Comprehensive scientific protocol - With the multiple levels of expresiveness and capability to define unlimited number of additional properties, it should be possible to utilize the protocol for definition and storage of specialized scientific data</t>
 <t>Strong building blocks - Provide well specified data representation and ability to construct even complex data structures from combining data type definitions from wide libraries</t>
 <t>Long-term storage - Provide way to define data with external or integrated specification</t>
</list>
</t>

</section>

<section anchor="appendix_examples_of_blocks" title="Appendix: Examples of Blocks">

<t>Examples of blocks and how their are encoded using XBUP protocol.</t>

<t>Fixed size node block with one attribute</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>02</c><c>AttributePartSize</c>
  <c>00</c><c>DataPartSize</c>
  <c>77</c><c>Attribute 1 of value 0x77</c>
</texttable>

<t>Terminated node block with one attribute</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>02</c><c>AttributePartSize</c>
  <c>7F</c><c>DataPartSize</c>
  <c>05</c><c>Attribute 1</c>
  <c>00</c><c>Terminator</c>
</texttable>

<t>Fixed size data block</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>01</c><c>AttributePartSize</c>
  <c>01</c><c>DataPartSize</c>
  <c>BB</c><c>One byte of data 0xBB</c>
</texttable>

<t>Terminated empty data block</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>01</c><c>AttributePartSize</c>
  <c>7F</c><c>DataPartSize</c>
  <c>00</c><c>Data block escape</c>
  <c>00</c><c>Termination value</c>
</texttable>

<t>Fixed size block with one child</t>
<texttable title="Stream Data">
  <ttcol>Byte</ttcol><ttcol>Value</ttcol>
  <c>02</c><c>AttributePartSize</c>
  <c>03</c><c>DataPartSize</c>
  <c>66</c><c>Attribute 1 of value 0x66</c>
  <c>  02</c><c>AttributePartSize</c>
  <c>  00</c><c>DataPartSize</c>
  <c>  77</c><c>Attribute 1 of value 0x77</c>
</texttable>

</section>

<section anchor="appendix_abstraction" title="Appendix: Abstraction">

<t>Primary focus on abstraction makes this protocol somewhat different compare to other similar binary formats which focus on efficiency, serialization or binary representation of a specific mark-up language. See <xref target="appendix_comparison">Formats comparison</xref> for more information.</t>

<t>This protocol technically overlaps in functionality with many currently widely used protocols and formats including those defined by various RFCs. It has also somewhat different nature compare to currently used typically text-based internet protocols (on higher layers). Therefore various aspects should be evaluated, whether potential advantages this protocol could provide overweight complexity and other possible issues, see <xref target="RFC3117"/> for design consideration.</t>

<t>With the primary focus on abstraction, data in the protocol are considered more as abstract entities than a specific method for data representation.</t>

<t>Catalog is then viewed more as a set of general entities with unique identifier - using set theory terminology, it's well-ordered countable of items.</t>

<t>On level 1 of the protocol, some of the items have specific meaning for definition of type and some are used to identify ownership and type definition.</t>

<t>Level 2 introduces transformation method item to define data conversion between two specific types (input and output) and various related items which allows to specify additional properties of types and transformations.</t>

<t>Higher levels then define additional new meanings of categories of items for additional relations and also introduces dynamic processes to generate them.</t>

<t>TODO</t>

</section>

<section anchor="appendix_parsing" title="Appendix: Parsing">

<t>Similar to parsing of textual formats, it's possible to provide parsing capability for binary protocol.

<list style="symbols">
<t>Object Model Parsing</t>
<t>Pull Parsing</t>
<t>Event Parsing</t>
<t>Hybrid Approaches</t>
</list>

</t>

<section anchor="parsing_level_0" title="Level 0 Parsing">

<t>To process level 0 protocol following 4 types of tokens are used:

<list style="symbols">

 <t>begin (terminationMode flag)</t>
 <t>attribute (UBNumber value)</t>
 <t>data (Binary data)</t>
 <t>end</t>

</list>
</t>

<t>Following simplified grammar can be used for token processing.</t>

<t>
<figure title="Simplified grammar">
 <artwork><![CDATA[
  Document ::= header + Block + data
  Block ::= begin + Attributes + Blocks + end | begin + data + end
  Blocks ::= Block + Blocks | epsilon
  Attributes ::= attribute + Attributes | epsilon
]]></artwork>
</figure>
</t>

</section>

<section anchor="parsing_level_1" title="Level 1 Parsing">

<t>To process level 1 protocol following 5 types of tokens are used:

<list style="symbols">

 <t>begin (terminationMode flag)</t>
 <t>type (block type)</t>
 <t>attribute (UBNumber value)</t>
 <t>data (Binary data)</t>
 <t>end</t>

</list>
</t>

<t>Newly added type token serves the purpose of identifying type of block. There are few methods how to represent type and it's possible to convert between them:

<list style="symbols">

 <t>Two attributes for groupId and blockId</t>
 <t>Pointer to block type in current type context</t>
 <t>Pointer to block type in main catalog</t>

</list>
</t>

</section>

<section anchor="parsing_level_2" title="Level 2 Parsing">

<t>With support for transformations, additional interface to request specific transformation is available.</t>

<t>Typical parsing on this level is performed in a manner, that specific block type ranges are requested for specific blocks and parsers provide automatically transformed data.</t>

<t>TODO</t>

</section>

</section>

<section anchor="appendix_comparison" title="Appendix: Comparison to Other Formats">

<t>While there are various binary formats and markup languages available, this project aims to take somewhat different approach to data representation.</t>

<t>
<list style="symbols">
 <t>While SGML, XML <xref target="XML"/> and related technologies were huge inspiration for this project, it seems that it wouldn't be feasible to use them as base for the binary variant due to attribute vs. child tag duality and use of Unicode string as a primitive data type in contrast to countable set used by this project</t>

 <t>Using binary format is basically a necessity to make protocol reasonable usable for universal data like for example audio or video even thou text formats (for example JSON <xref target="RFC4627"/>, YAML <xref target="YAML"/>) provide easy of use and readability advantages</t>

 <t>Compare to wide range of existing binary formats with fixed block structure (for example RIFF), this project aims to provide more unified access to all data structures and their definitions</t>

 <t>Compare to formats based on serialization of data primitives (for example Protocol Buffers <xref target="ProtoBuf"/>, CBOR <xref target="RFC7049"/>) this project aims to provide capability for data definitions which would make transmitting primitive types unnecessary</t>

 <t>Multi-level approach should allow to simplify and improve use compare to other dynamic binary formats (for example HDF5 <xref target="HDF5"/>, ASN.1 <xref target="ASN.1"/> and EBML <xref target="EBML"/>)</t>
</list>
</t>

</section>

<section anchor="appendix_ui" title="Appendix: User Interface">

<t>With unified tree structure it should be possible to provide tool which can process generic document encoded using XBUP protocol.</t>

<t>Following capabilities should be implemented:
<list style="symbols">

 <t>Show document as visual tree</t>

 <t>Show document as text using various syntaxes (including editing)</t>

 <t>Support catalog including external definitions</t>
 
 <t>Support for transformations including working with data in transformed form</t>

</list>
</t>

<t>Aim here is to provide comprehend tool to view and edit documents on different levels similar to what text editors provides for binary files representing text using typical encodings.</t>

<t>Additionaly, support for multiple syntaxes should allow to evolve syntax over time while underlying abstract concepts remain the same or it should be possible to adjust them via automatic transformations without constriction to syntax compatibility.</t>

<t>TODO</t>

</section>

</section>

<section anchor="IANA" title="IANA Considerations">

<t>In the current early state of the development of the protocol, just basic media type for general files is defined: application/x-xbup</t>

<t>TODO</t>

</section>

<section anchor="Security" title="Security Considerations">

<t>Security was not considered at current level of the development.</t>

</section>

<section anchor="Acknowledgements" title="Acknowledgements">

<t>TBD</t>

<iref item="Introduction" subitem="verbiage" primary="true"/>

</section>

</middle>

<back>

<references title="Normative References">

&RFC2119;

&RFC3629;

</references>

<references title="Informative References">

&RFC3117;

&RFC4627;

&RFC7049;

<reference anchor="ASN.1" target="https://www.itu.int/rec/T-REC-X.690">
  <front>
    <title>Information Technology -- ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
    <author fullname="International Telecommunication Union"/>
    <date year="1994"/>
  </front>
  <annotation>ITU-T Recommendation X.690</annotation>
</reference>

<reference anchor="YAML" target="https://www.yaml.org/spec/1.2/spec.html">
  <front>
    <title>YAML Ain't Markup Language (YAML[TM]) Version 1.2, 3rd Edition</title>
    <author initials="O." surname="Ben-Kiki" fullname="Oren Ben-Kiki"/>
    <author initials="C." surname="Evans" fullname="Clark Evans"/>
    <author initials="I." surname="Net" fullname="Ingy dot Net"/>
    <date year="2009" month="October"/>
  </front>
</reference>

<reference anchor="XML" target="https://www.w3.org/TR/2008/REC-xml-20081126/">
  <front>
    <title>Extensible Markup Language (XML) 1.0 (Fifth Edition)</title>
    <author initials="T." surname="Bray" fullname="Tim Bray"/>
    <author initials="J." surname="Paoli" fullname="Jean Paoli"/>
    <author initials="C. M." surname="Sperberg-McQueen" fullname="C. M. Sperberg-McQueen"/>
    <author initials="E." surname="Maler" fullname="Eve Maler"/>
    <author initials="F." surname="Yergeau" fullname="Francois Yergeau"/>
    <date year="2008" month="November"/>
  </front>
  <annotation>W3C Recommendation REC-xml-20081126</annotation>
</reference>

<reference anchor="XMLNamespaces" target="https://www.w3.org/TR/2009/REC-xml-names-20091208/">
  <front>
    <title>Namespaces in XML 1.0 (Third Edition)</title>
    <author initials="T." surname="Bray" fullname="Tim Bray"/>
    <author initials="D." surname="Hollander" fullname="Dave Hollander"/>
    <author initials="A." surname="Layman" fullname="Andrew Layman"/>
    <author initials="R." surname="Tobin" fullname="Richard Tobin"/>
    <author initials="H. S." surname="Thompson" fullname="Henry S. Thompson"/>
    <date year="2009" month="December"/>
  </front>
  <annotation>W3C Recommendation REC-xml-names-20091208</annotation>
</reference>

<reference anchor="EfficientXML" target="https://www.w3.org/TR/2014/REC-exi-20140211/">
  <front>
    <title>Efficient XML Interchange (EXI) Format 1.0 (Second Edition)</title>
    <author initials="J." surname="Schneider" fullname="John Schneider"/>
    <author initials="T." surname="Kamiya" fullname="Takuki Kamiya"/>
    <author initials="D." surname="Peintner" fullname="Daniel Peintner"/>
    <author initials="R." surname="Kyusakov" fullname="Rumen Kyusakov"/>
    <date year="2014" month="February"/>
  </front>
</reference>

<reference anchor="HDF5" target="https://support.hdfgroup.org/HDF5/doc/H5.format.html">
  <front>
    <title>HDF5 File Format Specification Version 3.0</title>
    <author fullname="The HDF Group"/>
    <date year="2016" month="April"/>
  </front>
</reference>

<reference anchor="EBML" target="https://datatracker.ietf.org/doc/draft-ietf-cellar-ebml/">
  <front>
    <title>Extensible Binary Meta Language</title>
    <author initials="S." surname="Lhomme" fullname="Steve Lhomme" />
    <author initials="D." surname="Rice" fullname="Dave Rice" />
    <author initials="M." surname="Bunkus" fullname="Moritz Bunkus"/>
    <date year="2020"/>
  </front>
  <seriesInfo name='Work in Progress,' value='draft-ietf-cellar-ebml'/>
</reference>

<reference anchor="IEEE.754.1985" target="">
  <front>
    <title>Standard for Binary Floating-Point Arithmetic</title>
    <author>
      <organization>Institute of Electrical and Electronics Engineers</organization>
    </author>
    <date year="1985" month="August"></date>
  </front>
</reference>

<reference anchor="ProtoBuf" target="https://developers.google.com/protocol-buffers/">
  <front>
    <title>Protocol Buffers</title>
    <author>
      <organization>Google</organization>
    </author>
    <date year="2020"></date>
  </front>
</reference>

</references>

</back>
</rfc>